<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_package_v0.16/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_package_v0.16/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_package_v0.16/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon_package_v0.16/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/favicon_package_v0.16/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"haah.kr","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="blog">
<meta property="og:title" content="ha-ah">
<meta property="og:url" content="https://haah.kr/page/12/">
<meta property="og:site_name" content="ha-ah">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="youngiggy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://haah.kr/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ha-ah</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=354302543"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":354302543,"only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="ha-ah" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ha-ah</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">로그, 게으른 로그</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">youngiggy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">116</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:youngiggy@gmail.com" title="E-Mail → mailto:youngiggy@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/profile.php?id=100001259884599" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100001259884599" rel="noopener me" target="_blank"><i class="fab fa-facebook fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/jooyoungiggy" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;jooyoungiggy" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/06/12/rest-the-big-lie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/06/12/rest-the-big-lie/" class="post-title-link" itemprop="url">REST - REST 좋아하시네</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-06-12 20:41:23" itemprop="dateCreated datePublished" datetime="2017-06-12T20:41:23+09:00">2017-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/06/12/rest-the-big-lie/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/12/rest-the-big-lie/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="RESTful-APIs-the-big-lie"><a href="#RESTful-APIs-the-big-lie" class="headerlink" title="RESTful APIs, the big lie"></a>RESTful APIs, the big lie</h2><p>이제 개발자들 사이에 널리 퍼진 REST에 대한 오해를 들춰볼 차례이다.</p>
<p>독자 입장에선 이 정성으로 그냥 논문을 읽지 그러냐는 의문도 들 수 있겠지만,</p>
<p>이 바닥의 수많은 오해를 발견하는 재미도 있었다.</p>
<h2 id="REST에-관한-끊이지-않는-논쟁"><a href="#REST에-관한-끊이지-않는-논쟁" class="headerlink" title="REST에 관한 끊이지 않는 논쟁"></a>REST에 관한 끊이지 않는 논쟁</h2><p>자신을 “SPA (UI&#x2F;UX&#x2F;server) architect and author”라고 소개하고 있는<br><em>Michael S. Mikowski</em>의 <a target="_blank" rel="noopener" href="https://mmikowski.github.io/the_lie/">RESTful APIs, the big lie</a>라는 자극적인 글과 댓글을 읽고 한번 정리해볼 필요가 있다고 생각했다.</p>
<p>댓글로 달려드는 모두가 REST나 API를 바라보는 관점이 다르고, 댓글을 읽으면서 ‘그래, 그렇지’하면서 나의 관점도 계속 흔들렸다.</p>
<p>내가 흔들렸던 이유는 이 글을 읽을 때는 막 REST에 대해 공부하기 시작했을 때였기도 했고, RESTful한 API를 만들기 위한 현실적인 고민들이 남일 같지 않았기 때문이기도… </p>
<p>그냥 REST라는 용어만 포기하면 편하다는 결론은 내 후속 블로그 글에서 다시 확인하시고, 일단 개싸움부터 들여다보자.</p>
<p>사실 블로그 자체는 REST를 이해하는데는 별로 도움이 안 되는 글이긴 한데, 이런 개싸움이야 말로 진짜 현실 세계(반 REST 진영이 가장 많이 언급하는 단어가 ‘real world’이다)의 문제인 듯!</p>
<p>주요 논점을 정리해보고, 딸린 댓글을 개발 새발 정리한 버전은 페이지 마지막에 붙여놓겠다.</p>
<h2 id="블로그-본문"><a href="#블로그-본문" class="headerlink" title="블로그 본문"></a>블로그 본문</h2><p>우선 블로그에서 저자가 주장하는 바를 짧게 정리해보자.</p>
<h3 id="Problem-1-There-is-little-agreement-on-what-a-RESTful-API-is"><a href="#Problem-1-There-is-little-agreement-on-what-a-RESTful-API-is" class="headerlink" title="Problem #1: There is little agreement on what a RESTful API is"></a>Problem #1: There is little agreement on what a RESTful API is</h3><p>HTTP 메소드와 응답코드는 모호해서 그 뜻이 정확히 뭘 의미하는지 사람마다 다르게 인식한다.</p>
<p>어떤 응답코드를 줄 지는 회사&#x2F;사람마다 다른 기준이 있을 수 있어서, client 입장에선 정확히 예측하기 어렵다.</p>
<h3 id="Problem-2-The-REST-vocabulary-is-not-fully-supported"><a href="#Problem-2-The-REST-vocabulary-is-not-fully-supported" class="headerlink" title="Problem #2: The REST vocabulary is not fully supported"></a>Problem #2: The REST vocabulary is not fully supported</h3><p>브라우저는 PUT과 DELETE같은 문법을 지원하지 않는다.</p>
<p>307 Temporary 같은 애들은 브라우저마다 상이하게 처리되기도 한다. 제대로 지원하는 건 200과 500뿐이다.</p>
<h3 id="Problem-3-The-REST-vocabulary-is-not-rich-enough-for-APIs"><a href="#Problem-3-The-REST-vocabulary-is-not-rich-enough-for-APIs" class="headerlink" title="Problem #3: The REST vocabulary is not rich enough for APIs"></a>Problem #3: The REST vocabulary is not rich enough for APIs</h3><p>HTTP의 문법은 풍부하지 못해서 모든 어플리케이션의 요청과 응답을 표현할 수 없다.</p>
<h3 id="Problem-4-RESTful-APIs-are-very-hard-to-debug"><a href="#Problem-4-RESTful-APIs-are-very-hard-to-debug" class="headerlink" title="Problem #4: RESTful APIs are very hard to debug"></a>Problem #4: RESTful APIs are very hard to debug</h3><p>그래서 REST로 통신할 때 문제가 생기면 7가지나 되는 조합으로 원인을 파악해야 한다.</p>
<ul>
<li>HTTP method (GET&#x2F;POST)</li>
<li>URI</li>
<li>실제로 사용하고 싶은 HTTP method (PUT&#x2F;DELETE..) in payload</li>
<li>진짜 메시지 in payload</li>
<li>응답코드</li>
<li>진짜 받아야 하는 응답코드 in payload </li>
<li>진짜 메시지 in payload</li>
</ul>
<p>이런 한계 때문에 어떤 문제가 발생했을 때, 디버깅을 위해 고려해야할 게 너무나 많다.</p>
<h3 id="Problem-5-RESTful-APIs-are-usually-tied-to-HTTP"><a href="#Problem-5-RESTful-APIs-are-usually-tied-to-HTTP" class="headerlink" title="Problem #5: RESTful APIs are usually tied to HTTP"></a>Problem #5: RESTful APIs are usually tied to HTTP</h3><p>HTTP에 너무 종속되어 있다.<br>HTTP가 아닌 다른 전송 방식으로 전환하려면 또 저 7가지 조합을 고려해서 만들어야 한다.</p>
<h3 id="The-way-forward-JSON-Pure-APIs"><a href="#The-way-forward-JSON-Pure-APIs" class="headerlink" title="The way forward: JSON-Pure APIs"></a>The way forward: JSON-Pure APIs</h3><p>그래서 제안하는 건, JSON-Pure APIs</p>
<ul>
<li>이 글이 쓰인 지 3주 후 JSON-Pure APIs에 관한 <a target="_blank" rel="noopener" href="https://mmikowski.github.io/json-pure/">후속 블로그</a>가 올라온다</li>
</ul>
<h2 id="논쟁"><a href="#논쟁" class="headerlink" title="논쟁"></a>논쟁</h2><p>블로그 본문과 댓글에서 발화한 여러 논쟁을 크게 묶어 정리해본다.</p>
<h3 id="HTTP-메소드와-응답코드는-모호해서-그-뜻이-정확히-뭘-의미하는지-사람마다-다르게-인식한다"><a href="#HTTP-메소드와-응답코드는-모호해서-그-뜻이-정확히-뭘-의미하는지-사람마다-다르게-인식한다" class="headerlink" title="HTTP 메소드와 응답코드는 모호해서 그 뜻이 정확히 뭘 의미하는지 사람마다 다르게 인식한다."></a>HTTP 메소드와 응답코드는 모호해서 그 뜻이 정확히 뭘 의미하는지 사람마다 다르게 인식한다.</h3><p>따지고 보면 그걸 모르는 사람의 문제지만, 현실적으로는 이해가 되는 부분도 있다.</p>
<p>어떤 응답 로직을 구현하기 위해 적합성 여부를 여러번 생각해야하는 것은 어쨌든 일종의 비용이라고 생각한다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://1ambda.github.io/javascripts/rest-api-put-vs-post/">https://1ambda.github.io/javascripts/rest-api-put-vs-post/</a> <ul>
<li>여기서 response code decision tree를 볼 수 있을 것이다<br><img src="http://i.stack.imgur.com/whhD1.png" alt="response code decision tree"></li>
</ul>
</li>
</ul>
<p>물론 이것은 REST의 문제가 아닌 구현상의 어려움일 뿐이다.</p>
<ul>
<li>이 글을 비판하는 진영에서는 ‘아니, 그게 왜 어렵다는 거야?’같은 반응을 보이기도 한다</li>
<li>사족이지만, npm 개발자인 <a target="_blank" rel="noopener" href="http://izs.me/">Isaac Z. Schlueter</a>는 세미콜론을 최대한 안 쓰는데, 이런 방식은 버그를 양산할 수 있고 혼란스러울 수 있다고 비판하는 사람들에게 ‘네가 JavaScript 문법을 몰라서 그렇다’고 일침하기도 했다</li>
</ul>
<p>요청 메소드와 응답 코드가 모든 상황을 담아낼 수 없다는 의견도 있는데, 이 글에 동조하는 사람들은 거대한 엔터프라이즈 환경(ERP, 병원 시스템 등)에서 다양하고 복합적인 리소스를 다루는 상황에 대해 언급한다.</p>
<p>논쟁을 지켜보며 생각이 드는 것은 - 추측이지만,</p>
<p>메소드가 충분치 않다는 감정은 특히 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C">RPC</a>를 실행하는 경우,<br>그러니까 내부적으로 복잡한 로직이 섞여있을 때 발생하는 것 같다. </p>
<p>예를 들어 리퀘스트를 날려서 설거지와 빨래와 아이 목욕을 시킨다면, 여기서 리소스란 무엇일까? 이 때는 어떤 메소드를 써야하는가?</p>
<p>이 지점부터 한차례 혼란이 오는 것 같은데, 그 리퀘스트를 보내는 대상 리소스가 우리가 흔히 인식하는 리소스, 그러니까 CSS나 이미지같은 소위 정적 리소스 개념을 벗어나는 지점부터 어려워지는 것 같다. </p>
<p>HTTP에서 <em>리소스란 뭐든 지 될 수 있다.</em></p>
<p>또한 REST를 CRUD로 치환하는 순간 이견은 좁혀지지 않는다. </p>
<p>조회&#x2F;등록&#x2F;수정&#x2F;삭제를 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE로 처리하는 게 REST라고 생각하면 더 이상의 이성적인 논쟁은 불가능해진다.</p>
<p>HTTP 메소드가 부족하다고 생각이 드는 건 모든 RPC 요청의 성격을 CRUD에 매핑하려는 시도에 원인이 있다고 본다.</p>
<p>어떤 기분인 지는 알 것 같다.</p>
<p>REST API는 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE를 쓰는 것 -&gt; 곧 조회&#x2F;등록&#x2F;수정&#x2F;삭제를 의미 -&gt; RPC 업무는 조회&#x2F;등록&#x2F;수정&#x2F;삭제 네 가지로 단순하게 떨어지지 않아!</p>
<p>각 HTTP 메소드가 정확히 어떤 의미인지는 각자 (제발 신뢰할 만한 출처에서) 찾아보기로 하고,</p>
<p>REST 논문에는 애초에 CRUD나 어떤 HTTP 메소드를 써야 한다는 언급이 없었다.</p>
<p>‘REST API는 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE를 쓰는 것이다’라는 공식은 웹 프레임웍의 잘못된 가이드에도 원인이 있기도 하다.</p>
<p><a target="_blank" rel="noopener" href="http://www.eq8.eu/blogs/37-post-create-and-put-update">Ruby on Rails의 예</a>를 보자.</p>
<ul>
<li>PUT을 썼더니 방화벽에서 막혔던 사례를 통해 이때 발생할 수 있는 문제를 다루고 레일스의 잘못된 가이드에 대해 언급한다</li>
<li>마지막 결론쯤에 Rails는 Rails일 뿐이라는 대목이 나온다</li>
<li>Best practice를 쫓아가면 좋긴하지만, 이해용이성을 조금 포기해야 하기도 한다</li>
</ul>
<p>PHP의 Laravel은 </p>
<ul>
<li>5.2 버전까지 <a target="_blank" rel="noopener" href="https://laravel.com/docs/5.2/controllers#restful-resource-controllers">RESTful Resource Controllers</a>라는 용어를 사용했으나,</li>
<li>5.3 버전부터는 <code>typical &quot;CRUD&quot; routes</code>를 제공한다는 설명과 함께 <a target="_blank" rel="noopener" href="https://laravel.com/docs/5.3/controllers#resource-controllers">Resource Controllers</a>라고 변경했다. 하지만 여전히 PUT은 UPDATE에 대응이 된다.</li>
</ul>
<h3 id="307-Temporary-같은-애들은-브라우저마다-상이하게-처리되기도-한다-제대로-지원하는-건-200과-500뿐이다"><a href="#307-Temporary-같은-애들은-브라우저마다-상이하게-처리되기도-한다-제대로-지원하는-건-200과-500뿐이다" class="headerlink" title="307 Temporary 같은 애들은 브라우저마다 상이하게 처리되기도 한다. 제대로 지원하는 건 200과 500뿐이다."></a>307 Temporary 같은 애들은 브라우저마다 상이하게 처리되기도 한다. 제대로 지원하는 건 200과 500뿐이다.</h3><p>좀 오버하는 감은 있긴 하다.</p>
<p>하지만 REST에서는 Uniform Interface가 중요한데도 경험적으로 (적어도 HTTP 쪽에서는) 인프라가 충분치 않다는 인식이 있는 것 같다. </p>
<p>위에 Ruby on Rails의 예에서 언급한 것처럼 보안을 이유로(?) PUT을 지원하지 않는 방화벽이랄지,</p>
<p>HTTP 응답 코드를 각기 다르게 해석하는 클라이언트 등 현실적인 제약은 다반사인 것 같다.</p>
<p>구현을 하는 입장에선 아무래도 이런 부분에선 부담이 되는 게 사실이다. (IE 대응을 위해 버려진 수많은 나날을 생각해보자)</p>
<h3 id="HTTP의-문법은-풍부하지-못해서-모든-어플리케이션의-요청과-응답을-표현할-수-없다"><a href="#HTTP의-문법은-풍부하지-못해서-모든-어플리케이션의-요청과-응답을-표현할-수-없다" class="headerlink" title="HTTP의 문법은 풍부하지 못해서 모든 어플리케이션의 요청과 응답을 표현할 수 없다"></a>HTTP의 문법은 풍부하지 못해서 모든 어플리케이션의 요청과 응답을 표현할 수 없다</h3><p>이것도 사실 각자의 상황에 맞는 Best Practice의 부재 탓이라고 본다.</p>
<p>HTTP가 끝없는 업계의 요구사항에 매번 응답코드를 추가해줄 수는 없다.</p>
<p>답답하겠지만 결국 개발자는 결정을 해야한다. 현실 세계의 문제는 원래 그렇다.</p>
<h3 id="RESTful-API는-디버깅-하기-힘들다"><a href="#RESTful-API는-디버깅-하기-힘들다" class="headerlink" title="RESTful API는 디버깅 하기 힘들다"></a>RESTful API는 디버깅 하기 힘들다</h3><p>이에 대한 반론 중에는 개발자도구나 HTTP client 툴을 사용하면 된다고들 하지만,</p>
<p>이 블로그 글쓴이의 의도는 요청&#x2F;응답 시 신경써야 하는 부분이 많다는 것이다.</p>
<p>난 맞는 지적이라고 생각한다.</p>
<p>SOAP이나 GraphQL처럼 응답 메시지 본문에서 모든 상황을 지켜보고 싶은 마음을 나도 십분 이해한다.</p>
<p>하지만 REST는 쉽게 개발하려고 만든 아키텍처 스타일이 아니다.</p>
<p>웹의 인프라를 충분히 활용해서 효율적으로 동작하고, 독립적으로 진화하고, 확장할 수 있게 설계하기하기 위함이다.</p>
<p>디버깅을 편하게 하기 위해 설계 원칙을 바꾸는 순간 본래의 목적에서 멀어진다.</p>
<h3 id="HTTP에-너무-종속되어-있다"><a href="#HTTP에-너무-종속되어-있다" class="headerlink" title="HTTP에 너무 종속되어 있다"></a>HTTP에 너무 종속되어 있다</h3><p>웹에서의 주요 프로토콜이 HTTP이긴 하고, 그 때문에 REST를 구현했다는 사람들이 HTTP를 많이 쓸 뿐이지 REST는 HTTP에 한정되지 않는다.</p>
<p><a target="_blank" rel="noopener" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_3_2">5.3.2 Connector View</a> 참고</p>
<h3 id="아무리-이론적으로는-맞는-말일-지라도-현실적으로는-대부분-HTTP-위에서-REST를-구현할-수-밖에-없잖아"><a href="#아무리-이론적으로는-맞는-말일-지라도-현실적으로는-대부분-HTTP-위에서-REST를-구현할-수-밖에-없잖아" class="headerlink" title="아무리 이론적으로는 맞는 말일 지라도, 현실적으로는 대부분 HTTP 위에서 REST를 구현할 수 밖에 없잖아"></a>아무리 이론적으로는 맞는 말일 지라도, 현실적으로는 대부분 HTTP 위에서 REST를 구현할 수 밖에 없잖아</h3><p>맞다. 웹개발자 입장에선 대부분의 API 설계를 HTTP 위에서 하게 된다.</p>
<p>하지만 그것이 REST가 HTTP에 종속됐다는 의미는 아니다.</p>
<h3 id="HTTP를-재발명-하자는-게-아니다-단지-어플리케이션-레벨의-메시지를-HTTP-안에-억지로-끼워넣지-말고-JSON-payload에-담자는-말이다"><a href="#HTTP를-재발명-하자는-게-아니다-단지-어플리케이션-레벨의-메시지를-HTTP-안에-억지로-끼워넣지-말고-JSON-payload에-담자는-말이다" class="headerlink" title="HTTP를 재발명 하자는 게 아니다. 단지 어플리케이션 레벨의 메시지를 HTTP 안에 억지로 끼워넣지 말고 JSON payload에 담자는 말이다."></a>HTTP를 재발명 하자는 게 아니다. 단지 어플리케이션 레벨의 메시지를 HTTP 안에 억지로 끼워넣지 말고 JSON payload에 담자는 말이다.</h3><p>그래도 된다고 생각한다. 다만 그렇게하면 REST라고 부르지 말자는 것이다. REST라고 부를 수 없다고 나쁜 설계는 아니다.</p>
<p>글쓴이가 제시하는 JSON-Pure API는 “json-ld&#x2F;hydra”와 같은 hypermedia를 사용하는 REST(중의적인 의미) 사람들을 따라하고 있을 뿐이라는 의견도 있다. (지원하는 클라이언트가 얼마 없지만…)</p>
<p>hypermedia를 구현하기 위한 수많은 API 표준이 존재하는데, 후속 블로그에서 더 다뤄보겠다.</p>
<h3 id="JavaScript를-비활성하면-REST를-쓸-수가-없다-HTML은-GET-x2F-POST밖에-지원하지-않는다"><a href="#JavaScript를-비활성하면-REST를-쓸-수가-없다-HTML은-GET-x2F-POST밖에-지원하지-않는다" class="headerlink" title="JavaScript를 비활성하면 REST를 쓸 수가 없다. HTML은 GET&#x2F;POST밖에 지원하지 않는다."></a>JavaScript를 비활성하면 REST를 쓸 수가 없다. HTML은 GET&#x2F;POST밖에 지원하지 않는다.</h3><p>계속되는 HTML의 PUT&#x2F;DELETE 지원 논쟁.</p>
<p>XHR을 쓰면 된다는 부류와 XHR을 못쓰는 환경이 있는데 어떡하냐는 부류가 자주 부딪힌다.</p>
<p>미안하지만 REST는 Architectural Styles일 뿐 당신들이 request 하나하나를 어떻게 구현하는지 관심이 없다.</p>
<p>내 개인적인 생각으로는 어느 시스템이든 각각의 제약 사항은 존재하기 마련이다.</p>
<p>부족하면 부족한대로 해결해내는 것이 개발자가 할 일이라고 본다.</p>
<p>그러다보면 REST의 제약사항을 어길 수밖에 없는 상황도 분명 올 수 있겠지.</p>
<p>다시 말하지만, 그럼 REST라고 안 부르면 된다!</p>
<p>가장 적당한 디자인을 설계하자.</p>
<h3 id="가서-SOAP으로-입-좀-행구고-오지-그래"><a href="#가서-SOAP으로-입-좀-행구고-오지-그래" class="headerlink" title="가서 SOAP으로 입 좀 행구고 오지 그래"></a>가서 SOAP으로 입 좀 행구고 오지 그래</h3><p>네가 하려는 건 SOAP과 다를 바 없다는 중의적 의미.</p>
<p>댓글에서 SOAP과의 비교를 하는 사람이 참 많다. 여기 <a target="_blank" rel="noopener" href="http://greatkim91.tistory.com/79">REST와 비교한 글</a>도 참고하자. </p>
<p>(이 블로그는 국내에서 보기 드물게 REST에 대해 정확한 표현을 하고 있음에도 이 글에서는 제대로 REST를 설명하고 있지 않는데, 그 이유는 <a target="_blank" rel="noopener" href="http://greatkim91.tistory.com/13">ROA에 관한 그 분의 다른 글</a>에서 볼 수 있다. 여기서 REST는 아키텍처 스타일, RESTful Web Service는 아키텍처로 구분하고 있는데, 이게 얼마나 신방성 있는지는 좀 더 찾아봐야겠다. ROA는 나중에 다시 다뤄보겠다.)</p>
<p>‘소위 REST’가 SOAP을 대체해 나간 것처럼 기술이 오래 살아남기 위해선 사람들이 얼마나 쉽게 받아들일 수 있는가도 무시할 수 없는 것 같다.</p>
<h3 id="결국-누군가-나서서-논쟁을-정리한다"><a href="#결국-누군가-나서서-논쟁을-정리한다" class="headerlink" title="결국 누군가 나서서 논쟁을 정리한다"></a>결국 누군가 나서서 논쟁을 정리한다</h3><p>(좋은 내용인데 이렇게 밖에 해석할 수 밖에 없어서 미안하다)</p>
<ul>
<li>REST는 API가 아니야. API를 디자인 하기 위한 패턴이야. 그것은 매우 엄격하게 또는보다 실용적인 방식으로 고수 될 수 있으며 현실 세계에서 구현하기 위한 모범 사례가 무엇인지에 대해 의견 차이가 있지.</li>
<li>XMLHttpRequest는 모든 CRUD문법을 지원하고 있어. 10년 정도를 넘지 않은 모든 메이저 브라우저는 REST를 완벽하게 지원해.</li>
<li>REST API는 도메인에 종속된 메시지 교환을 충실히 지원하는게 목적이 아니야. HTTP 레이어가 트랜잭션의 상태에 대한 정보를 갖고 있지. 즉, 일반적인 HTTP client와 프로토콜을 구현할 의무가 있는 서버에게 유용한 방식이야. 이 컴포넌트들이 도메인 특정의 어플리케이션이 도메인에 종속된 로직을 처리하도록 메시지 페이로드를 전달하고 있지. 이건 대부분의 메시지 교환 방식에서 사용하고 있어. 프로토콜에서 하나의 역할을 하는 시스템은 자신이 필요한 부분만 읽고 서브 시스템에게 넘겨주지. TCP&#x2F;IP 위에서의 HTTP 응답을 예로 들면 IP packet과 TCP 헤더는 HTTP client가 읽기도 전에 TCP client에서 읽히고 처리되지. 단순히 다음 프레임으로 넘어가서 메시지를 해석할 수 있는 어플리케이션 코드에게 메시지를 전달하면 되는데, 왜 굳이 HTTP 프로토콜을 확장해야 하는거지? 모든 REST 원칙은 URL이나 HTTP 동사와 같은 일반적인 개념을 제공하는 HTTP 프로토콜을 이용하고, 이를 페이로드 안에서 재발명하지 않을 것을 권고하고 있어. 그렇게 함으로써 페이로드의 내용을 더 가볍고 간단하게 만들 수 있고, 대부분의 HTTP client가 공짜로 제공해주는 캐싱 같은 이점도 누릴 수 있지.</li>
<li>네가 언급한 7가지 영역은 사실 모두 요청과 응답이라는 2개의 조각에 나뉘어 있어. 커스텀 JSON에 모두 묻어버릴 때와 같이 말이지. 다른 점이 있다면, 대부분의 개발자는 이미 이 형식에 익숙해서 HTTP 요청과 응답 안의 정확히 어디를 봐야할 지 안다는 사실이지. HTTP 인터렉션을 디버깅을 위한 (네 브라우저에도 있는) 훌륭한 툴을 모두 언급하지는 않을게.</li>
<li>내가 이미 지적했지만, REST는 API설계를 위한 패턴이지 HTTP로 제한된 건 아니야. RESTful한 디자인 관점은 네 API를 대부분의 전송 프로토콜 안에서 깨끗하고 일관되고 성능도 좋고 캐시하기도 좋게 도와주지. HTTP에서 적용하기 쉬운 이유는 REST의 많은 원칙들이 HTTP로부터 영향을 받았기 때문이야.</li>
<li>넌 프로토콜과 컨텐츠에 대해 혼란스러워하고 있어. 네가 말하고 있는 건, HTTP 프로토콜의 3가지 information 조각이야. 리소스 식별자, 명령어 동사, 응답 코드. 응답코드가 메시지 컨텐츠로 절대로 볼 수 없다고는 말할 순 없지만, 트랙잭션의 상태를 나타내는 표준 코드는 완전히 프로토콜의 일부야. 나머지 것들도 메시지 교환에서의 보편적인 개념이고 프로토콜 레이어 상에서 이를 명시하는 것은 아무런 해가 되지 않아.</li>
</ul>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>많은 사람들은 REST가 좋은 설계 패턴이라고 생각하면서 REST를 제대로 이해 못한 채 API&#x2F;서비스를 만들고 여기에 RESTful이라는 표현을 쓰고 있다.<br>그건 REST가 아니라고 말을 해줘도, 그럼 어떻게 구현하냐고 따지고 든다.</p>
<p><em>마치 REST라는 용어를 반드시 써야만 하는 사람들처럼.</em></p>
<p>2008년 논문의 저자 Roy도 사람들이 REST에 대해 오해하는 것에 대해 한탄하며 글을 썼는데, 이는 다음 포스트에서 다룰 예정이다.</p>
<p>이 논쟁에서 등장한 근거와 여러 링크가 궁금하다면 제일 하단 추천 링크도 확인해 볼 것!</p>
<h2 id="댓글-정리"><a href="#댓글-정리" class="headerlink" title="댓글 정리"></a>댓글 정리</h2><p>양이 너무 많아서 정말 대충 막 그냥 해석해서 써갈겼지만, 써 놓고 보니 또 아깝고 해서 쓸데 없지만 붙여 넣어본다.</p>
<p>각 댓글 앞에는 이 글에 대한 찬반 표시를 했다</p>
<ul>
<li>이 글에 찬성하는 편 &amp;#128077;</li>
<li>이 글에 반대하는 편 &amp;#128078;</li>
<li>쓸데없는 소리 &amp;#128169;</li>
</ul>
<hr>
<p>&amp;#128078; 너 정말 REST를 제대로 이해하는 거 맞어?<br>&amp;#128078; 그 문법이 좀 혼란스러운 건 맞어. 그런데 그건 HTTP의 문제 아니냐?<br>&amp;#128078; REST는 HTTP에 종속된 게 아니야</p>
<ul>
<li>&amp;#128169; 난 왜 이걸 (머릿속에서) 화난 목소리로 읽고 있는거야</li>
<li>&amp;#128077; 무슨 소리야. HTTP의 문법이 사용되고 있는데. 그리고 현실에선 99%는 HTTP위에서 쓴다고<ul>
<li>&amp;#128078; 로이 필딩의 논문 Section 5.2.1.2는 너랑 생각이 좀 다른 것 같은데? REST는 아무 representation이나 사용할 수 있어. 바이너리 프로토콜이라도 말이지.<ul>
<li>&amp;#128077; 원래 논문이 어쨌든 현실에선 아무 의미가 없어. 단지 몇 가지 아이디어와 이름만 가져왔을 뿐이라고.<ul>
<li>&amp;#128078; 아닌데? 최초 거기서 설명된 것이 바로 핵심이야. HTTP 동사와 상태 코드에 어플리케이션 관점의 의미를 부여하는 게 사실상의 REST의 의미가 되고 있지만, 내 생각엔 그건 REST의 핵심이 아니야. 하지만 오늘날의 이른바 REST를 원래 묘사된 것보다 더 관련있고 유용하고 정확하게 만들어주는 그런 구현이 없긴하지.</li>
<li>&amp;#128078; 어떤 면에서는 반대로 생각해. 어플리케이션 도메인의 의미를 HTTP 도메인으로 확장하려고 하면 좋은&#x2F;우수 사례는 존재하지 않아. 단지 다양한 의견, 느슨한 명세와 설명의 묶음이 될 뿐이지. 사실 그 중 어느것도 확실하게 실용적인 주장이라고 정당화하긴 어려워. 요즘 널리 퍼진 소위 RESTful 베스트 프랙티스는 대부분은 개발자들 기분 좋으라고 있는거지, 원래의 의미를 기초로 하거나 필요로 하지 않는 것들이야.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128078; 인터넷 이야기를 해보자고. 그 거대하게 연결된 웹 자체가 이미 REST가 잘 동작하는 훌륭한 예라고. 20만개의 사이트가 20년 후에도 잘 돌아갈 거야.</p>
<ul>
<li>&amp;#128077; 뭐가 잘 동작한다는 거야? 평이한 링크들은 관심도 없거니와 여기서 다루는 문제가 아니야. 여기선 REST가 어떻게 사용되고 있는가에 대해서 이야기 한다고. 특히 IPC같은 것들.</li>
<li>&amp;#128077; 20만개의 사이트가 잘 돌아가는 건 그동안 문서의 저장소로서 존재했기 때문이야.</li>
</ul>
<p>&amp;#128078; 오해를 한 것 같은데, REST는 전송 프로토콜과 언어에 대해서는 언급하고 있지 않아. 위키디피아를 봐 “RESTful systems typically, but not always, communicate over the Hypertext Transfer Protocol “<br>&amp;#128077; 당신이 아무리 철학적으로 올바른 말을 해도, HTTP위에서 REST를 구현하려는 시도는 어쩔 수 없는 현실이야. 쉽고 객관적으로 써보려고 노력했는데 잘 안된 것 같군. 곧 JSON-pure API에 관한 추가 포스팅을 올리도록 하지</p>
<ul>
<li><p>&amp;#128078; 신경질적으로 반응한 건 미안한데, 글 제목이 좀 자극적이긴 하잖아. 당신의 그 json-pure api는 어떻게 전송하는지 말해줄래?</p>
<ul>
<li>&amp;#128077; 우선 다음 포스트(링크)를 확인하면 많은 부분 답이 될 거야</li>
<li>&amp;#128077; REST에 관한 나의 묵상..이렇게 제목을 지어놓으면 누가 보기나 하겠어?</li>
<li>&amp;#128077; 난 HTTP를 재발명하자고 제안하는 게 아냐. http는 훌륭한 매커니즘이고, json은 GET이나 POST를 사용해 표준 application&#x2F;json contents-type으로 HTTP위에서 전송이 되지. 난 대부분의 어플리케이션 레벨의 메시지를 http안에 억지로 끼워넣지 말고 json안에 넣자는 거야. 그게 훨씬 api를 간편하고 신뢰할 수 있게 만들어 주니까.</li>
<li>&amp;#128077; 어쨌든 이미 많은 사람들이 이 문제를 지적했다고 확신해. 이게 뭐 대단한 것도 아니고. 난 웹개발자의 관점에서 전형적인 RESTful API 구현체가 왜 종종 안 좋은 방법인가에 대해 간략하게 정리하고 싶었을 뿐이야.</li>
<li>&amp;#128077; 추가: 내가 일반적인 http를 예로 들었지만, 이 방법은 쉽게 웹소켓이나 다른 전송 방식에서 구현할 수 있어. json에 요청과 응답에 필요한 거의 모든 것을 넣어놨기 때문이지.</li>
<li>&amp;#128078; 사실 너는 “json-ld&#x2F;hydra”와 같은 hypermedia를 사용하는 REST(중의적인 의미) 사람들을 따라하고 있을 뿐이야. 그 사람들이 더 잘하고, 표준도 만들고 있고, http를 해치지도 않지. 이미 존재하는 것을 이용하는 게 더 좋긴 하지만, 이 방식의 가장 큰 문제는 hypermedia의 개념이 아직 널리 퍼지지 않아서 지원하는 클라이언트가 엉망이라는 점이야. </li>
<li>&amp;#128077; 뭐하러 직렬화한 것을 전송하는데 contents-type까지 붙여야 하지?…(역주) 이렇게 시작하는 답글이 있으나 문장을 끊어쓰지 않아서 뭔 소린 지 잘 모르겠음. 어쨌든 다양한 클라이언트를 대응하고 클라이언트가 기대하는 대로 응답하기에는 좋은 생각인 것 같다는 말인 것 같음.</li>
</ul>
</li>
<li><p>&amp;#128077; 정말 재밌게 읽었어. api를 설계할 때 나눠야할 깊은 논의에 있어 좋은 출발점이 될 것 같아.</p>
<ul>
<li>&amp;#128077; 고마워 넌 다음 글도 좋아할 것 같아</li>
</ul>
</li>
<li><p>&amp;#128169; <em>에헴</em> graphql <em>에헴</em> (역주 graphql이란 게 있는데…란 )</p>
</li>
</ul>
<p>&amp;#128078; 디버깅하기 어렵고 DELETE&#x2F;PUT이 지원하지 않는다고? 지금 몇년도에 살고 있는거야?</p>
<ul>
<li><p>&amp;#128077; 2016에 html form에서 DELETE&#x2F;PUT이 지원하나보지? 지원 안하면 javascript를 disable시킨 환경에서 어떻게 rest를 사용할건데? - 이건 인터뷰 질문으로 쓰기 좋겠구만</p>
<ul>
<li>&amp;#128078; 누가 2016년에 request 보내는데 form을 쓰냐? 누가 2016년에 js를 끄고 브라우저를 쓰고 누가 js가 제공하는 기능을 모두 기대하겠냐고. js를 켜는 것은 2016년에는 필수라고.<ul>
<li>&amp;#128077; 많은 큰 기업에서 보안을 이유로 xhr을 끄고 form을 쓰도록 하고 있어. 이름을 댈 수는 없지만 많은 기업이 여전히 IE7을 쓰고 있고 심지어 일부는 xp에 ie6을 쓰고 있지.<ul>
<li>&amp;#128077; 그리고 ajax는 일반적인 브라우저의 네비게이션 히스토리를 따르고 있지 않아. 그렇다면 history api를 써야겠지? 그러다 이런 생각이 들거야. 왜 여전히 form이 html의 가장 주요한 스펙으로 남아있을까.</li>
<li>&amp;#128077; 나도 요즘엔 form이 덜 쓰인다고 생각해. 내가 하고싶은 말은, 당신이 어떤 길을 걸어갔던지 모든 문제는 항상 그렇게 간단하지만은 않다는 거야.</li>
</ul>
</li>
<li>&amp;#128169; 별 바보같은 댓글 다 보겠네 ㅋ 그럼 html5나 css도 호환성 문제가 있으니 갖다 버리라고 그래.</li>
<li>&amp;#128077; 많은 큰 기업들이 보안을 이유로 PUT과 PATCH를 막고 있어. 최근 일했던 곳에서 이 둘을 허가받기 위해 엄청 설명을 해야했어. 큰 기업 환경에선 완전한 RESTful은 아직 쉽지 않지.</li>
</ul>
</li>
</ul>
</li>
<li><p>&amp;#128078; 내가 오해를 하고 있나? 확인해보니 HTML에서 둘 다 잘 지원하는데?</p>
<ul>
<li>&amp;#128077; GET, POST, PUT and DELETE 이런 거는 다 HTTP 표준인데, HTML에서 지원하는 건 GET&#x2F;POST 밖에 없어. 최신 브라우저는 지원할지도 모르겠지만, 대부분의 개발환경은 2010~2013년 시대에 머물러 있어. <a target="_blank" rel="noopener" href="http://laraveldaily.com/theres-no-putpatchdelete-method-or-how-to-build-a-laravel-form-manually/">http://laraveldaily.com/theres-no-putpatchdelete-method-or-how-to-build-a-laravel-form-manually/</a> 이런 걸 봐.<ul>
<li>&amp;#128169; 1970년대에 살고 있으면 비주얼 베이직이나 어셈블러나 하시지. 지금 2017년이야 정신차려.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128169; 가서 비누(역주 : 그거 SOAP 아니냐는 중의적 의미)로 입 좀 행구고 오지 그래</p>
<ul>
<li>&amp;#128077; 웃긴 건 둘째치고, 이건 SOAP이랑 다른 거야. SOAP의 문제는 복잡성과 망할 스펙이지. 내가 해봐서 알아. 이건 너네의 HTTP 기반의 RESTful보다 훨씬 쉽다고.</li>
</ul>
<p>&amp;#128078; 마이클! 로이와 그의 논문에 대한 항목은 좀 축소하거나 삭제할 필요가 있어. 당신이 설명하는 것은 HTTP 위에서의 CRUD이지 로이가 설명했던 것과는 달라. 사실 그게 REST라고 불리고는 있지만, 로이의 논문과 관련있는 것은 단지 사람들이 완전히 다른 것을 가져오기 위해 납치한, 그가 사용한 REST란 이름 뿐이라고. REST에 대한 현대적 관행의 결점을 그의 탓으로 돌리는 건 공정하지 않아.</p>
<ul>
<li>&amp;#128077; 나도 당신의 의견에 동의하고, 당신이 쓴 그 내용을 서론에 추가해도 좋을 것 같아. 괜찮아? 내가 RESTful web services에 대해 논의했던 모든 웹개발자는 위에 쓴 그대로 REST를 설명하고 있었어. 맞아, 메소드들과 응답코드를 사용하긴 해도  기본적으로는 HTTP위에서의 CRUD일 뿐이지. 다음주에 더 설명해볼게.<ul>
<li>&amp;#128078; 고마워. hypermedia api를 한번 살펴봐 “RESTful Web API 웹 API를 위한 모범 전략 가이드”란 책이나 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/hypermedia-web">https://groups.google.com/forum/#!forum/hypermedia-web</a> 을 아직 모른다면. 거기선 사람들이 CRUD를 REST와 헷갈리지 않거든. 너도 아마 좋아할거야.</li>
</ul>
</li>
</ul>
<p>&amp;#128078; 난 네가 JSON을 사용하는 SOAP을 쓰자고 하는 것 같은데. 세세한 제약이 있는 RPC스타일 API가 어려운 건 다 이유가 있어. 많은 이가 지적했지만, 보통 오해하는 것처럼 REST가 CRUD는 아니야. HTTP 동사를 CRUD로 단순화하면 representation의 개념을 놓치게 돼. 이는 그 패턴이 잘 돌아가게끔 도메인 엔티티를 추상화하지. 나아가 각자가 정의한 의미들을 JSON payload에 담아보내는 것이  HTTP동사&#x2F;응답 패턴보다 쉽다고 하는게 이해가 안돼. 적어도  HTTP동사&#x2F;응답에 관해선 표준적인 사용법이 있잖아.</p>
<ul>
<li>&amp;#128078; 하나 더 이야기하자면, REST의 HATEOAS관점은 매우 중요해. 로이도 그렇게 이야기 했고. 그걸 지키지 않은 건 REST라고 할 수 없지. 이건 SOAP의 정적인 발견가능성을 넘어서, 제대로만 만든다면 API를 실시간으로 인터렉티브하게 만들어줄 수 있지.</li>
</ul>
<p>&amp;#128078; 이런 끔찍한 글을 쓰기 전에 REST나 공부해. 틀린 점을 말해줄게. #1. 코드의 의미는 API개발자들이 잘 이해하고 있어. #2. 동사들을 지원하기 위해 API 설계자들은 그걸 다 구현해야 하지(모든 웹 서비스가 다 그런 거잖아. 이상한 소릴 하는구만). 이건 API설계에 대한 이야기야. HTML이 몇몇 동사를 지원하지 않겠지만, API에 HTML을 사용해선 안돼. 그래서 JSON이나 XML을 써야하지. #3. 추가적인 동사는 필요없어. 리소스 기반 설계에 대해 공부 좀 해봐. 내가 아래에 몇가지 알려줄게. REST는 특히 캐싱에 대해 고려하거나 이로써 대역폭에 관해 효율적으로 동작해. #4. REST는 디버깅이 존* 쉬워. 브라우저나 Firebug, postman 등… 사실 REST가 가진 장점이라고 할 수 있지. 다른 웹서비스는 훨씬 더 어렵다고. #5. REST가 HTTP에 강력하게 묶일 필요는 없어. 다른 프로토콜을 섞어 쓸 수도 있고, 그게 안티 패턴도 아냐. 더 이상 나쁜 소리하기 싫으니까 조만간 내가 추천하는 걸 좀 찾아보길 바라. API-craft google group, Books: REST in practice, RESTful Web APIs, RESTful Webservices</p>
<ul>
<li>&amp;#128077; 트위터나 그런 10~20개 정도의 리소스를 매핑할 수 있는 아주 제한된 기능을 가진 사이트에서는 아주 훌륭한 이야기들이야. 그런데 이런 사이트들은 실제 비지니스 시스템에 비해 아주 원시적인 기능들만 제공할 뿐이야. 내가 10년이상 REST를 경험해봤는데, REST를 제대로 할 수 있는 시스템은 본적이 없어. 다른 사람들도 내가 하고있는 의료 분야처럼 복잡한 어플리케이션을 다루고 있어. 200개의 테이블이 있고, 150개의 트랜잭션을 위한 테이블이야 말할 것도 없고…REST를 사랑하시는 여러분이 내가 하고 있는 시스템에서 ‘적절한 REST’ 인터페이스를 정의해나가는 게 얼마나 걸릴지 궁금하군. 당연히 JSON RPC API가 유지보수하기에 훨씬 쉽고, 네가 REST로부터 멀어질 수록 더 단순하고 유지보수 비용이 줄게 되지. REST는 작은 서비스에서 쓰기 좋은 거라고.<ul>
<li>&amp;#128077; 브라우저에서 돌아가게 만든 ERP중에 REST로 구현할 놈은 하나도 없을 거라 생각해. 불행히도 많은 웹 개발자들은 ERP가 뭔지도 잘 몰라. 맨날 리소스, 확장성같은 거만 생가하지. 고객들은 빠른 응답과 브라우저에서 데스크탑 프로그램의 룩앤필을 갖는 것 등을 원하는데 말야. RESTful은 이걸 절대 이룰 수 없어. 요구사항이 적을 때나 가능한 일이라고.<ul>
<li>&amp;#128077; ERP에 대한 설명이 웃기네. 완전 맞는 말이야. 이해관계자들은 REST가 아닌 비지니스와 회계를 신경쓰지. 빠른 개발과 응답을 원하고. 아무도 백엔드가 어떻게 생겼는지 신경 안 써. 어마어마한 요구사항에는 SOAP이 더 낫지. 난 SOAP이 싫지만 의료업계의 회계같은 곳에선 더 간단하다고 볼 수 있지.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128077; 내가 본 대부분의 json api는 심지어 REST가 아냐. twitter의 ‘REST’ api를 봐. 물론 몇 개는 REST라고 할 수 있지만, 저건 RPC에 가깝지.<br>&amp;#128078; 결국 넌 REST의 목적을 이해하지 못하기 때문에 REST가 나쁘다고 말하는 거구나. </p>
<ul>
<li><p>&amp;#128077; 아니, 난 REST를 시도때도 없이 사용하는 게 안 좋다는 거야. (곧 릴리즈될) Facebook Relay and Netflix Falcor도 - 전통적인 RESTful API를 벗어나는 것에 대한 - 같은 주제를 다루고 있지.</p>
</li>
<li><p>&amp;#128078; xhr 클라이언트는 request를 위한 모든 환경을 제공하고 있어.</p>
<ul>
<li>&amp;#128077; 맞아. 그러나 그건 XHR뿐이지, 다른 영역에선 여전히 GET&#x2F;POST만 제공하거든. 그리고 응답코드에 대해 지원하는 수준도 천차만별이야. 오래된 브라우저는 더 심하고. 게다가 네 client가 patch 메소드를 보낼 수 있다고 쳐도 서버가 그걸 구현했다는 의미는 아냐.</li>
</ul>
</li>
<li><p>&amp;#128078; 네가 이런 혼동에서 빠져나오기를 바란다</p>
<ul>
<li>&amp;#128077; 첫째, 난 혼란스럽지 않아. 둘째, 인신공격이 널 더 똑똑하게 만들어주지 않아.<ul>
<li>&amp;#128078; 인신공격이라고? 넌 혼동하는 게 맞아. 그건 팩트라고. 다른 코멘트도 모두 네 논리에 대한 결함을 이기 하고 있고. 넌 네가 이해하지 못하거나 구현할 수 없는 것에 대해 배척하는 것 뿐야. </li>
<li>&amp;#128169; (역주) 이후 개싸움이라 생략…</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128169; 2 Years later … GraphQL is rising. And GraphQL only use 200 and 500.<br>&amp;#128077; API 제공자가 아닌 소비자로서의 나의 문제는, 어떻게 파라미터를 전달할 지, 서비스를 어떻게 노출할 지, 리턴 데이터가 어떻게 되어야 할지 일관된 방법이 없다는 것이다</p>
<ul>
<li>&amp;#128077; 기본적으로 HTML을 통한 REST는 form에서 PUT, POST 등을 지원하지 않기 때문에 완전하지 않다. 왜 RESTful하기 위해 굳이 form이 아닌 xhr을 써야하나? 삭제는 어떻게 해야하는거야? HTTP+HTML만으로는 실무에서 제대로 구현하는 게 불가능하지.</li>
</ul>
<p>&amp;#128078; 내 생각에 REST의 유일한 문제는 REST 자체가 아니라 그걸 쓰는 사람들의 문제야. 왜냐면 REST는 종종 HTTP와 혼동하거나 HTTP없이는 구현할 수 없다고 생각하거든. 너도 똑같은 실수를 하는 것 같다고 생각하는 이유는,  넌 HTTP의 상태코드나 동사에 대해 불만이 있다고 말을 하지만 그건 REST랑 상관이 없는 얘기거든. 그건 HTTP에 정의된 거라고. 물론 네가 REST를 HTTP를 통해 구현할 수 있기도 하고, REST를 구현한다는 서비스들이 99%는 http를 쓰고 그 속성을 상속받게 되긴 하지.</p>
<p>&amp;#128078; 네가 지적한 건 뭐 하나 제대로 된 게 없어</p>
<ul>
<li>1 . REST는 API가 아니야. API를 디자인 하기 위한 패턴이야. 그것은 매우 엄격하게 또는보다 실용적인 방식으로 고수 될 수 있으며 현실 세계에서 구현하기 위한 모범 사례가 무엇인지에 대해 의견 차이가 있지. </li>
<li>2 . XMLHttpRequest는 모든 CRUD문법을 지원하고 있어. 10년 정도를 넘지 않은 모든 메이저 브라우저는 REST를 완벽하게 지원해.</li>
<li>3 . REST API는 도메인에 종속된 메시지 교환을 충실히 지원하는게 목적이 아니야. HTTP 레이어가 트랜잭션의 상태에 대한 정보를 갖고 있지. 즉, 일반적인 HTTP client와 프로토콜을 구현할 의무가 있는 서버에게 유용한 방식이야. 이 컴포넌트들이 도메인 특정의 어플리케이션이 도메인에 종속된 로직을 처리하도록 메시지 페이로드를 전달하고 있지. 이건 대부분의 메시지 교환 방식에서 사용하고 있어. 프로토콜에서 하나의 역할을 하는 시스템은 자신이 필요한 부분만 읽고 서브 시스템에게 넘겨주지. TCP&#x2F;IP 위에서의 HTTP 응답을 예로 들면 IP packet과 TCP 헤더는 HTTP client가 읽기도 전에 TCP client에서 읽히고 처리되지. 단순히 다음 프레임으로 넘어가서 메시지를 해석할 수 있는 어플리케이션 코드에게 메시지를 전달하면 되는데, 왜 굳이 HTTP 프로토콜을 확장해야 하는거지? 모든 REST 원칙은 URL이나 HTTP 동사와 같은 일반적인 개념을 제공하는 HTTP 프로토콜을 이용하고, 이를 페이로드 안에서 재발명하지 않을 것을 권고하고 있어. 그렇게 함으로써 페이로드의 내용을 더 가볍고 간단하게 만들 수 있고, 대부분의 HTTP client가 공짜로 제공해주는 캐싱 같은 이점도 누릴 수 있지.</li>
<li>네가 언급한 7가지 영역은 사실 모두 요청과 응답이라는 2개의 조각에 나뉘어 있어. 커스텀 JSON에 모두 묻어버릴 때와 같이 말이지. 다른 점이 있다면, 대부분의 개발자는 이미 이 형식에 익숙해서 HTTP 요청과 응답 안의 정확히 어디를 봐야할 지 안다는 사실이지. HTTP 인터렉션을 디버깅을 위한 (네 브라우저에도 있는) 훌륭한 툴을 모두 언급하지는 않을게.</li>
<li>내가 이미 지적했지만, REST는 API설계를 위한 패턴이지 HTTP로 제한된 건 아니야. RESTful한 디자인 관점은 네 API를 대부분의 전송 프로토콜 안에서 깨끗하고 일관되고 성능도 좋고 캐시하기도 좋게 도와주지. HTTP에서 적용하기 쉬운 이유는 REST의 많은 원칙들이 HTTP로부터 영향을 받았기 때문이야.</li>
<li>넌 프로토콜과 컨텐츠에 대해 혼란스러워하고 있어. 네가 말하고 있는 건, HTTP 프로토콜의 3가지 information 조각이야. 리소스 식별자, 명령어 동사, 응답 코드. 응답코드가 메시지 컨텐츠로 절대로 볼 수 없다고는 말할 순 없지만, 트랙잭션의 상태를 나타내는 표준 코드는 완전히 프로토콜의 일부야. 나머지 것들도 메시지 교환에서의 보편적인 개념이고 프로토콜 레이어 상에서 이를 명시하는 것은 아무런 해가 되지 않아.</li>
<li>&amp;#128077; 여기에 블로그 글쓴이가 논점에 벗어난 댓글을 담<ul>
<li>&amp;#128078; 여기에 다른 이가 항의함<ul>
<li>네가 말하는 건 모두 DSL interface를 만들기 위해 REST의 원칙들을 왜곡하려는 것 같은 일이야. 난 개인 감정으로 네 주장에 대해 지적하는 게 아냐. 넌 너무 방어적이라고. 네가 지적한 기술적 문제는 REST에 대한 납득할 만한 비평이 아냐. 모두가 지적하는 부분에 대해 그저 동의하는 척 끝내버리고 있어. 넌 기술적인 원칙들과 네 안 좋은 경험들을 분리하는 데 문제가 있는 것 같아. REST가 의도하지 않은 방향으로 구현된 걸로 REST를 까지말고, 구체적으로 네가 생각하는 이상적인 기술적인 세부사항을 그려보지 그래? 네 블로그 글은 REST의 결함에 대한 이해는 되지 않고, 왜 그것이 종종 잘못 구현됨으로써 만능 해결책이 되지 않는지에 대한 내용 뿐이야.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128169; facebook이 GraphQL 내놓았어 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html">링크</a></p>
<ul>
<li>&amp;#128169; 그럼 이것도 읽어보지 그래? <a target="_blank" rel="noopener" href="https://www.pandastrike.com/posts/20151015-rest-vs-relay">링크</a><ul>
<li>역주 : facebook의 글도 REST를 제대로 이해하고 쓴 건 아닌 것 같고, 이를 비판하는 글도 GraphQL을 제대로 이해하는 것 같지는 않음</li>
</ul>
</li>
</ul>
<h2 id="댓글에서-언급된-추천-링크"><a href="#댓글에서-언급된-추천-링크" class="headerlink" title="댓글에서 언급된 추천 링크"></a>댓글에서 언급된 추천 링크</h2><p><em>로이 필딩이 이야기하는 HATEOAS에 관한 이야기</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a></li>
</ul>
<p>API Conf Panel: The Future of Media API</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/media-API">https://www.infoq.com/presentations/media-API</a></li>
</ul>
<p><em>GOTO 2014 • REST: I don’t Think it Means What You Think it Does • Stefan Tilkov</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=pspy1H6A3FM">https://www.youtube.com/watch?v=pspy1H6A3FM</a></li>
</ul>
<p>JSON-RPC</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.jsonrpc.org/specification">http://www.jsonrpc.org/specification</a></li>
</ul>
<p>Facebook의 GraphQL</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://graphql.org/learn/">http://graphql.org/learn/</a></li>
</ul>
<p>Netflix의 Falcor</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://netflix.github.io/falcor/">http://netflix.github.io/falcor/</a></li>
</ul>
<p>RESTful Web API 웹 API를 위한 모범 전략 가이드</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788966261635">http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788966261635</a></li>
</ul>
<p>Hypermedia Web discussion group</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/hypermedia-web">https://groups.google.com/forum/#!forum/hypermedia-web</a></li>
<li>CRUD와 REST를 구별할 줄 아는 사람들</li>
</ul>
<p>API Craft google group</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://groups.google.com/forum/?hl=ko#!forum/api-craft">https://groups.google.com/forum/?hl=ko#!forum/api-craft</a></li>
</ul>
<p>Hypermedia Client Tutorial</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apiacademy/2016-07-hyperclient">https://github.com/apiacademy/2016-07-hyperclient</a></li>
</ul>
<p>From Zero to Hyper in 30 Minutes: Live Coding a Hypermedia Client</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/http-client-javascript">https://www.infoq.com/presentations/http-client-javascript</a></li>
</ul>
<p>CODE COMPLETE 2</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788956742564">http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788956742564</a></li>
</ul>
<p><em>Your API isn’t RESTful — And That’s Good</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@trevorhreed/you-re-api-isn-t-restful-and-that-s-good-b2662079cf0e">https://medium.com/@trevorhreed/you-re-api-isn-t-restful-and-that-s-good-b2662079cf0e</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/24/rest-the-dissertation-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/24/rest-the-dissertation-summary/" class="post-title-link" itemprop="url">REST - 논문(요약) 훑어보기</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-24 12:06:17" itemprop="dateCreated datePublished" datetime="2017-05-24T12:06:17+09:00">2017-05-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/24/rest-the-dissertation-summary/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/24/rest-the-dissertation-summary/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="논문"><a href="#논문" class="headerlink" title="논문"></a>논문</h2><p>REST의 사전적인 의미부터 알아보자.</p>
<p>‘바쁜 개발자들을 위한 REST 논문 요약’을 요약 + WhatIsRest.com + 지난 며칠간 블로그와 댓글을 뒤져가며 얻은 지식 + 내 생각을 적어보려고 한다.</p>
<h2 id="REST-제약-조건"><a href="#REST-제약-조건" class="headerlink" title="REST 제약 조건"></a>REST 제약 조건</h2><p>논문에서는 아무것도 없는 웹 스타일에서 시작해, 제약 조건을 하나씩 추가해 나가며 REST 스타일을 유도해 나가는 과정을 통해 REST를 설명한다.</p>
<ol>
<li>Starting with the Null Style</li>
<li>Client-Server</li>
<li>Stateless</li>
<li>Cache</li>
<li>Uniform Interface</li>
<li>Layered System</li>
<li>Code-On-Demand</li>
</ol>
<p>각 제약 조건을 취하면서 발생하는 trade-off도 언급하고 있으나 여기서는 넘어가기로 한다.</p>
<h3 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client-Server"></a>Client-Server</h3><p>보통 생각하는 서버-클라이언트를 의미.</p>
<p>여기서 의문이 들었던 게, Client-Server라는 게 과연 제약조건이라고 할 수 있는 건가? 그러니까, 제약 조건을 어기는 게 과연 가능한가?</p>
<p>이 제약조건은 클라이언트와 서버의 역할을 명확하게 구분한다 정도로 생각하면 될 것 같다.</p>
<p>서로의 관심사를 분리하여 각각의 로직의 독립적인 진화를 지원해야 한다(중요).</p>
<h3 id="Stateless"><a href="#Stateless" class="headerlink" title="Stateless"></a>Stateless</h3><p>모든 요청은 필요한 모든 정보를 담고 있어야한다.</p>
<p>요청 하나만 봐도 바로 뭔지 알 수 있으므로 가시성이 확보된다.</p>
<p>API 문외한 입장에서 가장 이해가 안 됐던 부분 중 하나였다. 인증을 위해 쿠키를 심고 세션에서 필요한 정보를 가져오는 경우, 이는 stateless인가 아닌가?</p>
<ul>
<li>정답 : Session 정보 활용한다면 stateless가 아니다</li>
</ul>
<p>REST에서는 각각의 요청에 서버가 필요한 정보가 모두 담겨야 한다.</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>모든 서버 응답은 캐시 가능한 지 그렇지 않은 지 알 수 있어야 한다.</p>
<p>캐시를 고려한 설계가 필요하다.</p>
<h3 id="Uniform-Interface"><a href="#Uniform-Interface" class="headerlink" title="Uniform Interface"></a>Uniform Interface</h3><p>구성요소(클라이언트, 서버 등) 사이의 인터페이스는 균일(uniform)해야한다.</p>
<ul>
<li>이것만으로는 무슨 말인지 모르겠다</li>
</ul>
<p>WhatIsREST.com의 내용을 구글 번역으로 돌려보면 </p>
<ul>
<li><code>소비자는 많은 소비자와 서비스에서 표준화 된 방법, 미디어 유형 및 공통 리소스 식별자 구문을 통해 서비스 기능에 액세스합니다</code>라고 나오는데,<br>미디어 유형이나 리소스 식별자 등을 의미하는 문법이 구성요소나 호환 시스템 간 동일해야 한다는 의미</li>
</ul>
<p>균일한 인터페이스가 필요한 이유는</p>
<ul>
<li>서버 입장에선 어떤 클라이언트든 상관없이(내가 보내주는 것을 이해할 수 있을까 걱정없이) 표준에 의한 응답을 해줄 수 있고</li>
<li>클라이언트 입장에선 hypertext를 통해 다음 상태로의 이동을 해야하는데, 표준화된 방식을 통해 해당 서버의 특성을 알 필요가 없어진다</li>
<li>서로의 특성을 알지 못해도 커뮤니케이션이 가능할 수 있어야, 각각 독립적으로 진화할 수 있는 유연한 시스템이 만들어진다</li>
</ul>
<p>REST는 네가지 Interface 제약조건으로 정의된다</p>
<p><a target="_blank" rel="noopener" href="http://exyus.com/articles/rest-the-short-version/">네가지 Interface 제약조건</a>에서 언급된 내용을 구글 번역으로 좀 더 상세히 살펴보자.</p>
<ul>
<li>이 자원의 추상적 정의는 웹 아키텍처의 핵심 기능을 가능하게 합니다</li>
<li>유형이나 구현에 따라 인위적으로 구별하지 않고 많은 정보 소스를 포괄함으로써 보편성을 제공합니다 </li>
<li>표현에 대한 참조의 늦은 바인딩을 허용하여 요청의 특성에 따라 내용 협상을 수행 할 수 있습니다 </li>
<li>저자는 개념의 단수 표현보다는 개념을 참조 할 수 있으므로 표현이 바뀔 때마다 기존의 모든 링크를 변경할 필요가 없습니다</li>
</ul>
<h4 id="1-identification-of-resources"><a href="#1-identification-of-resources" class="headerlink" title="1. identification of resources"></a>1. identification of resources</h4><p>리소스를 식별하는 방법이 동일해야 한다. 우리는 보통 URI를 쓰기 때문에 어쩐지 당연한 말처럼 느껴진다.</p>
<h4 id="2-manipulation-of-resources-through-representation"><a href="#2-manipulation-of-resources-through-representation" class="headerlink" title="2. manipulation of resources through representation"></a>2. manipulation of resources through representation</h4><p>representation의 개념은 <a target="_blank" rel="noopener" href="https://blog.npcode.com/2017/04/03/rest%EC%9D%98-representation%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/">이응준님 블로그</a>에서 다루고 있다.</p>
<p>리소스의 표현계층(representation)을 리소스의 식별자(URL)로부터 분리한 것은 REST에서 아주 주요한 관점이다.</p>
<p>RESTful 응용 프로그램은 동일한 URI에서 동일한 자원의 표현을 둘 이상 지원할 수 있다.</p>
<h4 id="3-self-descriptive-messages"><a href="#3-self-descriptive-messages" class="headerlink" title="3. self-descriptive messages"></a>3. self-descriptive messages</h4><p>요청이나 응답 메시지에는 이를 이해하기 위한 모든 정보가 포함되어야 한다.</p>
<h4 id="4-hypermedia-as-the-engine-of-application-state"><a href="#4-hypermedia-as-the-engine-of-application-state" class="headerlink" title="4. hypermedia as the engine of application state"></a>4. hypermedia as the engine of application state</h4><p>줄여서 HATEOAS라고도 하지만 REST를 사랑하는 이들은 종종 이렇게 줄여부르는 걸 싫어하기도 한다(똑똑하고 재수없게 보이려면 ‘HATEOAS라고 줄여 부르는 건 바보같다’라고 말하면 된다).</p>
<p>훗날 블로그에서 Roy는 이 부분을 가장 강조하는데, 어쩌면 사람들이 가장 안 지키고 있기 때문일 지도 모르다는 생각을 했다.  </p>
<p>그리고 이를 언급할 때 주로 hypertext라는 표현을 사용한다.</p>
<p>논문에서 hypermedia라고 한 것은 단지 text가 아닌 매체를 고려했기 때문이고,</p>
<p>일반적인 API에서는 거의 hypertext라고 표현하면 된다.</p>
<p>음? 우리가 HTML 페이지에서 맨날 보는 그 hypertext라는 용어가 맞나?</p>
<p>맞다. 제시된 hypertext 위에서 application 상태를 변경하는 주체가 client가 되어야 한다는 게 핵심이다.</p>
<p>조대협님의 블로그에는 <code>HTTP Response에 다음 Action이나 관계되는 리소스에 대한 HTTP Link를 함께 리턴하는 것</code>이라고 언급이 되어 있다.</p>
<ul>
<li>뭔가…이상한데…틀렸다고 하기는 뭣 하지만 온전히 이해가 되는 문장은 또 아니다. 다른 사람의 의견을 더 들어보자</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://community.oracle.com/blogs/mkarg/2010/02/14/what-hateoas-actually-means">What HATEOAS actually means</a></p>
<ul>
<li>다들 혼란스러워하는 것 같은데 직접 로이 필딩에게 물어보지 그래?</li>
<li>로이의 문장은 명확하고, 모호하지도 않으니 그냥 읽어보길 바란다</li>
<li>로이가 HTTP 표준의 기여자라는 것을 잘 생각해보자</li>
<li>이 논문의 주제는 WWW가 잘 동작하고 확장성도 좋고, REST가 WWW 아키텍쳐 위에서 동작한다면, 이 역시 잘 동작하고 확장성이 좋다는 것이다</li>
<li>4가지의 제약 조건은 결국 URI를 사용해서 MIME-typed 문서를 GET&#x2F;PUT 등으로 전송하는 것 + HATEOAS</li>
<li>WWW :&#x3D; URI + HTTP + MIME + Hypermedia</li>
<li>Hypermedia라는 건 hypertext를 확장한 개념</li>
<li>좀 더 정확하게 쓰자면, HATEOAS :&#x3D; hypermedia documents as the state of state</li>
<li>로이의 배경을 생각하면 그는, 하이퍼링크가 없는 HTML 도큐먼트를 상상조차 못할 인물이다</li>
<li>그가 언급한 Hypermedia란 문서 자체를 의미한다</li>
<li>로이는 HTTP통신에 Link header를 넣어도 여전히 RESTful 할 수 있지만, 합당한 이유가 있어야 한다고 했다<ul>
<li>역주) 헤더에 넣으면 이를 처리할 수 없는 클라이언트도 있을 수 있기 때문에..라고 했는데 당시에는 LINK가 정식 표준이 아닌 때였기 때문인 것 같음</li>
</ul>
</li>
<li>HATEOAS를 정확히 구현한 것은 문서안에 있는 링크다</li>
<li>HATEOAS라는 다음 상태 변경을 위한 링크(form 링크 등)를 제공해야 한다는 것</li>
</ul>
<p>이 문서도 좀 제멋대로 해석한 부분이 있는데, Roy는 단지 HTTP만을 염두에 둔 게 아니다. HTTP이거나 HTML 문서이거나 그런 게 중요한 게 아니다.<br>HATEOAS라는 걸 응답에 다음 액션에 관한 링크를 전달하는 것 정도로 생각하면 안 된다.</p>
<ul>
<li>응답에 링크를 주렁주렁 달고 다니면 HATEOAS가 되는가? NO!</li>
<li>서버는 Hypermedia를 통해 다음 액션에 대한 선택지를 클라이언트에게 줘야한다</li>
<li>클라이언트는 서버의 독자적인 진화에 영향을 받아선 안 되며, 서버 상의 구현에 의존하면 안 된다</li>
</ul>
<p>결국 HATETOAS의 목적은 (서버-클라이언트 간 의존성을 분리해야만 가능한) 독자적인 진화와 확장을 보조하는 것이며, hypermedia는 그 목적을 이루는 데 기여해야 한다   </p>
<h3 id="Layered-System"><a href="#Layered-System" class="headerlink" title="Layered System"></a>Layered System</h3><p>클라이언트든 서버든 미들웨어 구성요소를 추가할 수 있는 구조.</p>
<p>하지만 Client-Server 사이에선 그 구성요소가 추가되는지, 다른 서비스와 추가로 통신하는 지 여부는 관심없다.</p>
<p>서버와 클라이언트 간 상호 작용을 일관성있게 유지해야 한다.</p>
<h3 id="Code-On-Demand-Optional"><a href="#Code-On-Demand-Optional" class="headerlink" title="Code-On-Demand (Optional)"></a>Code-On-Demand (Optional)</h3><p>서버가 네트워크를 통해 클라이언트에 프로그램을 전달하면 그 프로그램이 클라이언트에서 실행될 수 있어야한다. (Java applet이나 Javascript 같은 것을 말함).</p>
<p>다만 이 제약조건은 필수는 아니다.</p>
<h2 id="thanks-to"><a href="#thanks-to" class="headerlink" title="thanks to"></a>thanks to</h2><p><a target="_blank" rel="noopener" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">로이 필딩의 논문</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.npcode.com/">이응준님의 블로그</a>에서 많은 영감을 얻음</p>
<p><a target="_blank" rel="noopener" href="http://whatisrest.com/">WhatIsREST.com</a></p>
<p><a target="_blank" rel="noopener" href="http://exyus.com/articles/rest-the-short-version/">네가지 제약조건에 대한 짧은 설명</a> </p>
<p><a target="_blank" rel="noopener" href="https://community.oracle.com/blogs/mkarg/2010/02/14/what-hateoas-actually-means">HATEOAS가 진짜로 의미하는 것</a> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/23/rest-http-method-in-html-form/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/23/rest-http-method-in-html-form/" class="post-title-link" itemprop="url">REST - HTML Form에서 GET/POST만 지원하는 이유</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-23 23:12:12" itemprop="dateCreated datePublished" datetime="2017-05-23T23:12:12+09:00">2017-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/23/rest-http-method-in-html-form/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/23/rest-http-method-in-html-form/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="HTML-Form에서-GET-x2F-POST만-지원하는-이유"><a href="#HTML-Form에서-GET-x2F-POST만-지원하는-이유" class="headerlink" title="HTML Form에서 GET&#x2F;POST만 지원하는 이유"></a>HTML Form에서 GET&#x2F;POST만 지원하는 이유</h2><p>쉬어가는 마음으로 다음 장을 위한 사전 지식을 하나 쌓아보자.</p>
<p><a target="_blank" rel="noopener" href="http://jxck.hatenablog.com/entry/why-form-dosent-support-put-delete">왜 PUT과 DELETE를 지원하지 않는가</a>에 대한 정리</p>
<ul>
<li>일본어다. 구글 번역기를 돌려보자</li>
</ul>
<p>PUT&#x2F;DELETE를 Form에 넣으려는 시도는 위 글에서 가장 자세히 나오긴 했다.</p>
<p>(구글 번역이 훌륭하긴 해도) 일본어라 원본을 알아볼 수가 없으므로,<br>대신 <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/114156/why-are-there-are-no-put-and-delete-methods-on-html-forms">stackexchange에 올라온 글</a>로 짧게 정리해봤다.</p>
<ul>
<li>초기 HTML5 draft에는 포함되어 있었고 Firefox의 베타 버전에서는 잠시 구현하기도 했었다.</li>
<li>W3C는 이 문제를 <a target="_blank" rel="noopener" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671">bug report 10671</a>에서 논의를 했는데,</li>
<li>Mike Amundsen이란 사람이 언급하길<ul>
<li>리소스를 수정하기 위해 PUT과 DELETE를 실행하는 건 모던 브라우저의 XmlHttpRequest 객체를 사용하면 간단한데, 스크립트를 사용하지 않는 상황에선 쉽지 않다.</li>
<li>이 패턴은 많은 일반적인 웹 프레임웍&#x2F;라이브러리에서 기본으로 구현하고 있다.</li>
<li>(그리고 이를 우회하는 방식에 대한 문제를 언급함)</li>
</ul>
</li>
<li>Tom Wardrop란 사람도 흥미로운 관점을 제시함<ul>
<li>HTML은 HTTP와 떼려야 뗄 수 없는 관계다. HTML은 인간을 위한 HTTP 인터페이스다. 따라서 왜 HTTP에서 필요한 메소드를 모두 제공하지 않는 것인가에 대해 자동으로 의문을 가질 수 밖에 없다. 기계는 PUT과 DELETE를 할 수 있으면서 인간은 왜 안 되는가?</li>
<li>HTML이 시맨틱한 마크 업을 보장하는 데 많은 시간을 할애하면서, 시맨틱한 HTTP 요청을 보장하기 위한 노력을 하지 않았다는 것은 모순이다.</li>
</ul>
</li>
<li>결국 이 버그는 (HTML editor인) Ian Hickson에 의해 고치지 않는 것으로 결정났다.<ul>
<li>“PUT을 form 메소드로 사용한다는 것은 말도 안 된다. 네가 form payload를 통해 PUT을 해야할 일은 없을 것이다. DELETE도 payload가 없어야만 말이 된다. 그러니 역시 form에서 제공할 이유가 없다.”</li>
</ul>
</li>
<li>하지만 포기하지 않고 추가 드래프트가 올라와 있다<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/2015/NOTE-form-http-extensions-20150929/#http-put-form">https://www.w3.org/TR/2015/NOTE-form-http-extensions-20150929/#http-put-form</a></li>
</ul>
</li>
</ul>
<p>일본어로 정리된 글에서도 왜 PUT과 DELETE가 Form에서 적합하지 않은지는 생각하진 않은 것 같다.</p>
<p>추가된 드래프트도 결국 애초의 HTML Form이 가진 기능&#x2F;목적을 우회하여 Form을 활용한 PUT&#x2F;DELETE를 실행할 수 있도록 Form의 기능 확장(extension)을 요구하고 있다.<br>여기에서 DELETE는 크게 이질감이 없지만, PUT의 경우 payload를 통해 헤더를 구성하는 방식을 제안하고 있다. 그 방식은 꽤나 어색해서 과연 HTML 에디터나 커뮤니티 차원에서 받아들일 수 있을지는 미지수이다.</p>
<p>이슈를 닫아버린 Ian Hickson 입장에선 Form에서 PUT&#x2F;DELETE를 지원하는 게 너무 당연하게 말도 안 되는 일이라고 생각했을 것 같다. 이유는,</p>
<ul>
<li>Form은 서버에 정보를 제출하기 위해 존재한다</li>
<li>GET과 POST는 form에 존재하는 대화형 컨트롤에 입력된 값을 보낸다</li>
<li>POST와 PUT의 가장 큰 차이<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">RFC2616</a>에서는 ‘요청 URI의 다른 의미’라는 표현을 썼고 </li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231#section-4.3.4">RFC 7231</a>에서는 ‘동봉된 representation에 대한 다른 의도’라는 표현을 썼다 </li>
<li>POST에서의 요청 대상 리소스는 동봉된 representation을 ‘처리하는’ 주체이고</li>
<li>PUT에서는 동봉된 representation은 대상 리소스의 상태를 대체한다. 즉, 리소스 자체가 되어야 한다</li>
</ul>
</li>
<li>따라서<ul>
<li>GET은 form에 있는 정보를 줄테니 나에게 리소스(representation)를 줘</li>
<li>POST는 form에 있는 정보를 줄테니 이걸로 처리 좀 해줘</li>
</ul>
</li>
<li>라는 의미가 되지만,<ul>
<li>DELETE에서 URI는 리소스를 정확하게 식별하고 요청을 보내기 때문에 form을 통해 값을 전달할 게 없으며<ul>
<li>권한을 획득하기 위해선 header를 이용해야할 것 같다</li>
</ul>
</li>
<li>PUT도 전송해야할 것은 대상 리소스를 대체할 representation 그 자체인데, 대상 리소스더러 조각난 form 데이터를 처리하라고 보낼 수는 없는 노릇</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/22/rest-the-beginning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/22/rest-the-beginning/" class="post-title-link" itemprop="url">REST - 긴 여정의 시작</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-22 01:30:00" itemprop="dateCreated datePublished" datetime="2017-05-22T01:30:00+09:00">2017-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/22/rest-the-beginning/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/22/rest-the-beginning/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="Representational-State-Transfer"><a href="#Representational-State-Transfer" class="headerlink" title="Representational State Transfer"></a>Representational State Transfer</h2><p><a target="_blank" rel="noopener" href="https://blog.npcode.com/2017/03/02/%EB%B0%94%EC%81%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-rest-%EB%85%BC%EB%AC%B8-%EC%9A%94%EC%95%BD/">바쁜 개발자들을 위한 REST 논문 요약</a></p>
<blockquote>
<p>REST는 Representational State Transfer의 줄임말로, 웹을 위한 네트워크 기반 아키텍처 스타일이다. REST는 Roy T. Fielding이 그의 박사학위 논문 “Architectural Styles and the Design of Network-based Software Architectures” 에서 처음 소개하였다.</p>
</blockquote>
<p>아하.</p>
<p>가장 중요한, Roy의 실제 논문을 아직 읽지 못했다. 논문의 대략적인 내용은 위에 링크를 걸어둔 이응준님의 블로그로부터 이해를 했다.</p>
<p>REST와 HTTP를 이해하기 위해 필수적인 representation의 개념도 그 분의 블로그에서 얻을 수 있으니 미리 보고 올 것을 권한다. </p>
<ul>
<li>representation이란 용어를 단순히 ‘표현’이라고만 번역하기에는 뭔가 놓치는 의미가 있는 것 같아서, 일단은 계속 representation이라고 부르겠다</li>
</ul>
<p>몇 가지 이해 안 되던 부분은 실제 논문으로부터 갈증을 해소하기도 했지만,</p>
<p>논문 전체를 자세히 해석해 나가기에는 지금 좀 지쳤으니 (언젠가) 후속으로 정리를 해야겠다.</p>
<p>지금 시점에는 내가 RESTful하게 설계할 일이 없을 것 같긴 하지만,</p>
<p>웹을 이해하기에는 꽤 좋은 관점이 들어있(다고 추측이 된)다.</p>
<h2 id="REST-아키텍처-스타일"><a href="#REST-아키텍처-스타일" class="headerlink" title="REST 아키텍처 스타일"></a>REST 아키텍처 스타일</h2><p><code>바쁜 개발자들을 위한 REST 논문 요약</code>을 읽기에도 바쁜 개발자들을 위해 요약하자면,</p>
<p>논문에서 Roy는 소프트웨어 아키텍처, 네트워크 기반 어플리케이션 아키텍처, 네트워크 기반 아키텍처 스타일 등을 설명하고,</p>
<p>네트워크 기반 아키텍처의 요구사항, 해결해야할 문제 등을 제시하는데 이에 대한 해결책으로 REST 아키텍처 스타일을 제안한다. </p>
<p>REST는 소프트웨어 아키텍처가 아닌 <a target="_blank" rel="noopener" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm">아키텍처 스타일(architectural style)</a>이라고 정의한다.</p>
<p>후속으로 올릴 REST에 대한 논쟁에서도 REST는 아키텍처 스타일이라고 여러번 강조한다.</p>
<p>많은 IT 용어가 건축에서 왔는데(건축 뿐이겠는가..), 영어권에서는 동일한 단어를 사용하는 서로 다른 용어(동음이의)가 우리말로 번역되면서 각각 다른 단어로 표현되곤 한다.</p>
<p>따라서 어떤 IT 용어가 가진, 원래의 단어에서 오는 뉘앙스나 메타포를 놓치는 경우가 많아 비영어권 국민으로서 참 아쉽다.</p>
<p>많은 REST 논쟁에서 REST를 이해 못하는 사람들이 좀 더 구체적으로 예시를 들어줄 것을 요구하면, 사람들은 REST가 아키텍처 스타일이라고 강조하는 경우가 많았던 것 같다.</p>
<p>아키텍처 스타일(architectural style)은 건축양식을 의미한다. </p>
<p>중세에 고딕양식이 유행을 했다는 말은 고딕양식에 기반해 건물을 설계하고 이 설계를 구현한 건물이 많았다는 말이고(내가 건축 양식의 문외한임은 미리 고백한다),</p>
<p>고딕 성당을 지으려는 설계자는 이 양식을 지키는 선에서 ‘알아서’ 설계를 해야한다.</p>
<p>시장은 설계나 세부 구현에 대한 이해없이 고딕 양식이라는 틀 안에서 요구사항을 제시할 것이고 그러다보면 설계에서도, 구현에서도 best practice가 퍼지게 되겠지.</p>
<p>수십개의 성당을 지어야 하는 작업 반장의 커뮤니티에서는 이 세부 구현이 곧 고딕 양식이다라고 인식될 수 있다. 그가 얼마나 뛰어난 작업 반장인지와는 상관없이.</p>
<p>물론 이런 식의 건축 양식이 시간을 두고 확립되었다면, REST는 태초에 명확한 제약사항이 존재했다는 차이가 있긴 하다.</p>
<p>기와집이라는 건축양식이 있다고 할 때, 청기와 주유소는 과연 기와집인가? (기와는 맞는데 집이 아닌가? 흠..)</p>
<p>아니라면 기와집이라는 건축양식을 현대에는 의미를 확장해야할 필요가 있지 않은가? </p>
<p>어쩌면 사회적 합의를 봐야할 지도 모르겠다.</p>
<p>REST처럼 작성자가 확실하며, 애초에 확실한 제약 사항이 있는 분야도 합의의 대상인가?</p>
<hr>
<p>REST에 관해서는 온갖 블로그와 구현체에서 서로 다르게 해석하고 있다.</p>
<p>작성자의 역량 + 독자의 역량이 오해를 재생산하기도 한다.</p>
<p>그러니 지금 이 정리를 본 누군가도 역시 오해를 얻어가리라 믿는다. 나 때문이든 당신 때문이든.</p>
<p>우선 REST에 대해 알아보자.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/18/learning-api-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/18/learning-api-design/" class="post-title-link" itemprop="url">API Design을 들여다보다</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-18 23:28:44" itemprop="dateCreated datePublished" datetime="2017-05-18T23:28:44+09:00">2017-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/18/learning-api-design/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/18/learning-api-design/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h2><p>생각해보니 내가 API를 제대로 만들어 본 적이 없었더랬다.</p>
<p>GraphQL이 재미있어 보이니 써보고는 싶은데, </p>
<p>사실 난 인증을 붙인 프로덕션 레벨의 코드를 만들어 본 적이 없다.</p>
<p>왜 좋은가를 설명하려면 널리 퍼진 아키텍처 스타일을 기반으로 설명하면 좋을텐데,</p>
<p>나는 REST는 설명할 수 있던가? HTTP는?</p>
<p>나는 정확히 설명할 수 없다.</p>
<p>그럼 해야지.</p>
<p>지금까지는 지식 습득의 드라이브를 발표를 통해 얻었다면, 이제 블로그에 정리하면서 익혀보려고 한다.</p>
<h2 id="What-to-do"><a href="#What-to-do" class="headerlink" title="What to do"></a>What to do</h2><p>‘정확히 알기’ 그 첫번째 과정으로 API 디자인에 도전해본다.</p>
<p>이 시리즈가 끝날 즈음이면 나는</p>
<ul>
<li>API 서버를 구축해서 인증을 붙여본다</li>
<li>전통적인 RESTful API와 GraphQL 서버 모두 구현</li>
<li>REST에 대해 제대로 설명하게 된다</li>
<li>여러 인증 과정을 경험해본다</li>
<li>HTTP에 대해 설명을 할 수 있게 된다</li>
</ul>
<p>동시에</p>
<ul>
<li>HTTP 완벽가이드 릴레이 세미나<ul>
<li>HTTP 완벽가이드로 적당히 완벽히 알기(금새 또 적당히 적당히 하려는 버릇이..)</li>
<li>여기에 몇가지 간단한 책(그림으로 배우는 시리즈)도 참고로 읽기</li>
</ul>
</li>
</ul>
<h2 id="And-how"><a href="#And-how" class="headerlink" title="And how?"></a>And how?</h2><p>검색과 블로그와 책으로부터 얻은 지식을 에버노트에 거칠게 정리한 다음 블로그에 옮겨 담기로..</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/18/declare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/18/declare/" class="post-title-link" itemprop="url">블로그를 시작하겠노라고 선언하다</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-18 22:02:20" itemprop="dateCreated datePublished" datetime="2017-05-18T22:02:20+09:00">2017-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/18/declare/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/18/declare/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="내가-은연-중-피하려고-했던-것들"><a href="#내가-은연-중-피하려고-했던-것들" class="headerlink" title="내가 은연 중 피하려고 했던 것들"></a>내가 은연 중 피하려고 했던 것들</h2><p>기술 블로그와 신세 한탄이 섞여있겠지만,</p>
<p>익숙하지 않은 것을 시도해보기로 했다.</p>
<h2 id="그리고-2017-05-18-오늘"><a href="#그리고-2017-05-18-오늘" class="headerlink" title="그리고 2017.05.18 오늘"></a>그리고 2017.05.18 오늘</h2><p>오랜만에 제창된 임을 위한 행진곡</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/UdKgerP9O7Q" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>RIP. Chris Cornell</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/IuUDRU9-HRk" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youngiggy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"youngiggy-github-io","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
