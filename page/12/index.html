<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_package_v0.16/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_package_v0.16/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_package_v0.16/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon_package_v0.16/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/favicon_package_v0.16/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css" integrity="sha256-/4UQcSmErDzPCMAiuOiWPVVsNN2s3ZY/NsmXNcj0IFc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"haah.kr","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.15.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="blog">
<meta property="og:title" content="ha-ah">
<meta property="og:url" content="https://haah.kr/page/12/">
<meta property="og:site_name" content="ha-ah">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="youngiggy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://haah.kr/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ha-ah</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=354302543"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":354302543,"only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="ha-ah" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ha-ah</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">로그, 게으른 로그</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">youngiggy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:youngiggy@gmail.com" title="E-Mail → mailto:youngiggy@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/profile.php?id=100001259884599" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100001259884599" rel="noopener me" target="_blank"><i class="fab fa-facebook fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/jooyoungiggy" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;jooyoungiggy" rel="noopener me" target="_blank"><i class="fab fa-instagram fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/06/28/rest-the-coclusion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/06/28/rest-the-coclusion/" class="post-title-link" itemprop="url">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-06-28 00:15:16" itemprop="dateCreated datePublished" datetime="2017-06-28T00:15:16+09:00">2017-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/06/28/rest-the-coclusion/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/28/rest-the-coclusion/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<p>Update: “Your API isn’t RESTful — And That’s Good”에 대한 요약번역본은 숨겨놨다가, 원문을 쓴 Trevor Reed에게 요약본을 번역하여 퍼뜨리는 것에 대해 댓글로 문의한 후, 재배포함.  </p>
<hr>
<h2 id="Hypertext-HATETOAS-for-API"><a href="#Hypertext-HATETOAS-for-API" class="headerlink" title="Hypertext, HATETOAS for API"></a>Hypertext, HATETOAS for API</h2><p>여러 동영상을 찾아보다, <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=RY_kMXEJZfk">2016년에 진행중인 API 스펙들에 관해 이야기하는 강연</a>을 봤다</p>
<ul>
<li>REST의 핵심은 hypertext이다</li>
<li>2016년의 API 스펙들<ul>
<li>JSONAPI</li>
<li>HAL</li>
<li>Hydra (JSON-LD)</li>
<li>Collection+JSON</li>
<li>…</li>
<li>GraphQL</li>
</ul>
</li>
</ul>
<p>이들 스펙 만으로는 RESTful하다고 볼 수는 없지만, hypertext에 대한 관점에 공감을 하며 이를 표준 스펙을 통해 풀어나가려는 시도가 이어지고 있다.</p>
<p>좋은 시도이고 꾸준히 발전하길 기원한다.</p>
<p>그러나 지금까지 다루었던 개발자들의 몰이해는 이런 실질적인 구현체가 없었기 때문인가?</p>
<p>튜토리얼 몇 번 따라하고 실무에 적용할 만 한가? 그러면 RESTful API가 될 수 있나?</p>
<p>어렵다고 본다.</p>
<h2 id="REST-or-not"><a href="#REST-or-not" class="headerlink" title="REST or not"></a>REST or not</h2><p>사람들이 싸우는 것은 항상 이런 식이다.</p>
<ul>
<li>제약 사항을 지키지 않았다면 그것은 REST가 아니다. 세상은 REST와 REST가 아닌 것으로 분류된다</li>
<li>현실적으로 그걸 다 지키기는 어렵다. Roy 지도 못하면서! 난 내 작품을 REST라고 부를거야</li>
</ul>
<p>수많은 논쟁을 지켜보면 든 생각은, REST에 대해 잘못 알고있는 사람들(어쩌면 당신과 나)을 비난하며 선을 긋지 말자는 것이다.</p>
<p>인터넷에 돌아다니는 99%의 글이, 그 좋은 회사(트위터, 페이스북…)에서 통용되는 용어들이, 단지 몇가지 URL 규칙과 HTTP 메소드가 필요했을 뿐인 사람들이 REST란 용어를 납치했다.</p>
<p>비슷한(?) 예로, 선풍기를 쐬고 자면 죽는다는 미신은 증명하기는 너무나 어렵고 오랜기간 광범위하게 퍼졌으며 전문가들도 경고했으며 모두가 믿기 때문에, 많은 이가 오늘도 타이머를 맞추고 잔다.</p>
<p>그러니까 난 지금 선풍기를 쐬고 자도 안 죽는다는 미신을 숭배하고 있다. 여전히 난 어떤 게 미신인지 증명할 수 없다.</p>
<p>REST뿐 아니라, IT뿐 아니라, 우리는 많은 것을 블랙박스 안에 넣어놓거나 혹은 추상화된 개념으로 이해하고 넘어간다.</p>
<p>블랙박스를 열어보니 다른 게 들어있었다면, 그저 예상과 달랐다고 담백하게 말해보자.</p>
<p>REST를 잘못 알고 있다고 해서, 그가 실력도 없고 뭔가를 자세히 알아볼 생각도 없는 겉멋든 사람이라고 할 수는 없다.</p>
<p>‘난 XX를 안다고 착각하는 부류를 알고 있어. 그런 사람들은 보통 XX한 사람들이지’라며 선풍기 타이머를 돌리지 말자는 이야기다. (물론 난 다른 이유로 타이머를 애용한다)</p>
<p>특정 관점이 다른 사람들을 경계 밖으로 몰아내 모든 교류를 끊지 않았으면 한다.</p>
<hr>
<p>로이 필딩은 REST에 관한 논문은 전문가를 위한 논문이라고 <a target="_blank" rel="noopener" href="http://roy.gbiv.com/untangled/tag/specialization">언급</a>한 적이 있다.</p>
<p>REST는 설계를 위한 지침이지 초심자도 따라할 수 있는 best practice를 제공하는 것이 아니다.</p>
<p>쉽게 말해, 어렵다.</p>
<h2 id="RESTful-gt-RESOURCEful"><a href="#RESTful-gt-RESOURCEful" class="headerlink" title="RESTful -&gt; RESOURCEful"></a>RESTful -&gt; RESOURCEful</h2><p>사실 간단한 해결책이 있다.</p>
<p>이 모든 혼란은 REST이라는 용어를 쓰지 않으면 해결된다.</p>
<p>RESTful하지 않다는 것이 실패한 디자인이라는 뜻이 아니다.</p>
<p>다만, 그동안 통용됐던 의미의 REST를 통칭할 수 있는 새로운 용어가 필요하다는 말이다.</p>
<p>마지막으로 이 글을 읽어보자.</p>
<p>이 글에서 그동안 REST라고 잘못 명명된 몇가지 구현 원칙을 RESOURCEful API라는 새로운 이름으로 재정의하고 있다.</p>
<h2 id="Your-API-isn’t-RESTful-—-And-That’s-Good"><a href="#Your-API-isn’t-RESTful-—-And-That’s-Good" class="headerlink" title="Your API isn’t RESTful — And That’s Good"></a>Your API isn’t RESTful — And That’s Good</h2><p>2016년 3월 31일에 발행된 Trevor Reed이란 사람의 블로그를 읽어보자.</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/@trevorhreed/you-re-api-isn-t-restful-and-that-s-good-b2662079cf0e">https://medium.com/@trevorhreed/you-re-api-isn-t-restful-and-that-s-good-b2662079cf0e</a></p>
<p>현 상황을 가장 명확하게 정리한 글로 보인다.</p>
<h4 id="The-Background"><a href="#The-Background" class="headerlink" title="The Background"></a>The Background</h4><ul>
<li>2000년에 로이 필딩은 Architectural Styles and the Design of Network-based Software Architectures라는 논문을 발표한다</li>
<li>비슷한 시기(1999년)에 Web 2.0이니 시맨틱 웹이니 자신들의 아이디어를 더욱 혁신적으로 보이게 만들어주는 유행어가 등장한다</li>
<li>이 아이디어는 웹 서비스로 이어지고 SOAP이나 XML-RPC같은 웹 서비스를 구현하기 위한 많은 사양이 나타나기 시작했다</li>
<li>하지만 이는 구현하기 복잡하고 성능 문제도 발생했다</li>
<li>이런 API 제공을 위한 더 간단한 방식으로 월드 와이드 웹이 제기되었다</li>
<li>분산 하이퍼미디어 시스템을 위한 고도로 정교한 아키텍처 스타일이 대중적인 아이디어의 원시적인 힘과 충돌한 시점이 바로 이쯤이다.</li>
<li>사람들은 SOAP 같은 프로토콜 대신 간단하고 표준적인 대안을 원했다</li>
<li>REST의 아이디어 중 일부는 필요에 잘 부합했지만 전부는 아니었다</li>
<li>그래서 사람들은 필요한 것을 가져갔고 나머지는 무시했다.</li>
<li>REST라는 용어는 무시하지 않고 잘도 가져갔다. 그들은 새로운 웹 API 개념을 위해 그 용어를 빌려갔다</li>
<li>로이 필딩의 노력에도 불구하고, 인터넷은 REST라는 용어를 납치하여 도망쳤다</li>
<li>REST, RESTful, REST API 등의 용어는 모든 종류의 API 구현체에 사용되고 있다.</li>
</ul>
<h4 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h4><ul>
<li>API 개발을 하려는 많은 사람들이 REST를 API 구축을 위한 일련의 베스트 프랙티스로 인식한다</li>
<li>REST를 제대로 이해한다면, 그게 자신들이 예상한 것과 다르다는 걸 깨닫는다</li>
<li>이해하는 것과는 상관없이, 그게 자신들이 필요로 하는 것보다 많다는 걸 깨닫는다</li>
<li>그래서 그냥 ‘나름 RESTful’한 API를 만들어 버린다</li>
<li>REST 유스 케이스는 서버와 클라이언트가 강하게 결합하지 않아야만 한다</li>
<li>클라이언트는 서버가 제공하는 하이퍼미디어를 탐색하는 방법만 이해하면 된다</li>
<li>가장 일반적인 예는 월드 와이드 웹이다</li>
<li>브라우저는 클라이언트이고, URL은 응용프로그램 상태를 나타내며 사용자는 하이퍼미디어를 탐색하는 방법을 결정한다(링크 클릭 등)</li>
<li>많은 웹 API는 이와는 대조적으로 클라이언트와 강하게 결합되어 있고 하이퍼미디어가 부족하기 때문에 REST의 원칙을 위반한다</li>
<li>API의 엔드포인트는 클라이언트가 개발될 때 이미 알고 있고, 클라이언트 안에 하드코딩 되어 있기 때문에, API의 엔드포인트를 발견하기 위한 하이퍼미디어 사용은 불필요하다</li>
</ul>
<h4 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h4><ul>
<li>우리가 필요로하는 것은 밀접하게 결합 된 웹 API의 일반적인 사용 사례를 공식적으로 정의하고 표준화하는 것이다</li>
<li>혼란을 종식시키기 위해서는 이 개념을 새로 명명해야한다</li>
<li>이를 통해 커뮤니티는 “REST”의 개념과 혼란과는 별개로 강력한 표준 및 모범 사례를 구축 할 수 있다</li>
</ul>
<h4 id="RESOURCEful-APIs-A-New-Name-An-Old-Concept"><a href="#RESOURCEful-APIs-A-New-Name-An-Old-Concept" class="headerlink" title="RESOURCEful APIs: A New Name, An Old Concept"></a>RESOURCEful APIs: A New Name, An Old Concept</h4><ul>
<li>RESOURCEful API : 새로운 이름, 오래된 개념</li>
<li>다음의 조건을 만족할 때 RESOURCEful하다고 간주된다<ul>
<li>API는 HTTP를 전송 레이어로 사용해야만 한다 (MUST)</li>
<li>모든 API 엔드 포인트(URL)은 명사로 구성되어야 하며, 리소스, 리소스 모음 또는 리소스 속성을 나타낸다</li>
<li>컬렉션에 속한 리소스는 컬렉션 URL을 접두어로 하는 URL에서 접근할 수 있어야 한다<ul>
<li>리소스에 속한 서브 컬렉션이나 속성은 리소스의 URL을 접두어로 해서 접근할 수 있어야 한다</li>
</ul>
</li>
<li>API 버전 및 리소스 식별 매개 변수는 URL 경로에 있어야 한다<ul>
<li>다른 모든 매개변수는 쿼리 문자열 혹은 헤더에 있어야 한다</li>
</ul>
</li>
<li>실제 동작을 나타내는 API 호출은 작업큐 혹은 작업 대행자로 표시되어야 한다. 이 둘은 여전히 명사이다. 이들의 동작을 트리거하는 데는 HTTP POST 메소드가 사용되어야 한다<ul>
<li>역주) 의역하자면 “동작을 나타내는 API는 그 동작 자체를 명사로 나타내야 하며, 이때 HTTP 메소드는 POST를 사용한다” 정도로 하면 될 것 같다</li>
</ul>
</li>
<li>구현된 HTTP 메소드는 HTTP Method spec에 따라 정의된 목적으로 사용되어야 한다</li>
<li>구현된 HTTP 메소드는 안전함(Safe)과 멱등성(Idempotent) 원칙을 준수해야 한다</li>
<li>HTTP 상태코드는 정의된 용도에 따라 모든 응답에서 사용되어야 한다<ul>
<li>200은 다른 가능한 상태코드가 있을 지라도 모든 성공적인 요청 결과의 응답 코드로 사용 수 있다</li>
</ul>
</li>
<li>요청이나 응답의 본문은 자원, 자원의 모음 혹은 자원의 특성을 나타내야 한다</li>
<li>요청이나 응답의 본문의 형식은 Content-Type 헤더로 지정해야 한다</li>
<li>API가 요청 본문의 형식을 지원하지 않으면 415(Unsupported Media Type) 상태를 반환해야 한다</li>
<li>응답 본문의 형식은 가능하다면 Accept 헤더에서 요청한 형식이어야 한다<ul>
<li>API가 요청 본문의 형식을 지원하지 않으면 406(Not Acceptable) 상태를 반환해야 한다</li>
</ul>
</li>
</ul>
</li>
<li>또한 아래와 같은 우수 사례를 권장한다<ul>
<li>URL을 소문자로 만들기</li>
<li>특정 HTTP 메소드나 상태코드를 지원하지 않는 client를 위한 대체 수단을 만들기<ul>
<li>예를 들어 JSONP는 모든 응답에 200 상태 코드를 필요로 한다</li>
</ul>
</li>
<li>JSON 형식은 항상 지원할 것 - XML은 선택 사항</li>
<li>항상 HTTPS를 통해 호스팅할 것</li>
<li>API가 새로운 리소스를 생성할 때는 응답 어딘가에 해당 자원의 식별자를 반환해야 함</li>
</ul>
</li>
</ul>
<h4 id="Examples-amp-References"><a href="#Examples-amp-References" class="headerlink" title="Examples &amp; References"></a>Examples &amp; References</h4><ul>
<li>일반적인 HTTP 메소드<ul>
<li>GET — safe, idempotent —요청된 URL에서 리소스의 representation을 검색한다</li>
<li>POST — not safe, not idempotent — 제출된 리소스의 representation을 요청된 URL 아래 새로운 위치에 생성한다</li>
<li>PUT — not safe, idempotent — 제출된 리소스의 representation을 요청된 URL의 위치에 저장하고 이미 존재한다면 대체한다</li>
<li>PATCH — not safe, not (necessarily) idempotent — 제출된 정보를 통해 요청된 URL의 리소스를 부분적으로 업데이트한다. 존재하지 않는 리소스에 대한 PATCH 시도는 400 상태 코드와 함께 실패해야 한다</li>
<li>DELETE — not safe, idempotent — 요청된 URL에 있는 리소스를 삭제한다</li>
</ul>
</li>
<li>비동기 작업 큐에서 HTTP 메서드의 동작<ul>
<li>GET - 큐 또는 큐의 특정 태스크에 대한 정보 검색</li>
<li>POST - 큐에 작업 추가</li>
<li>PUT - 큐의 기존 작업 업데이트</li>
<li>PATCH - 큐에 있는 기존 작업을 부분적으로 업데이트</li>
<li>DELETE - 큐에서 작업 제거</li>
</ul>
</li>
<li>작업 대행자(agent)에 대한 HTTP 메소드의 동작<ul>
<li>GET - 에이전트 또는 그의 동작 중 하나의 상태를 검색</li>
<li>POST - 원하는 동작 트리거</li>
<li>PUT - 정의되지 않음</li>
<li>패치 - 정의되지 않음</li>
<li>DELETE - 가능한 경우 이전에 트리거 된 동작을 취소</li>
</ul>
</li>
<li>공통 HTTP 상태 코드 - 2XX 레벨 상태 코드를 제외한 모든 것이 실패로 간주된다<ul>
<li>200 OK - 응답 성공</li>
<li>201 Created - 요청 본문에 제출된 엔티티가 (동기적으로) 생성되었다</li>
<li>202 Accepted - 요청 본문에 제출된 엔티티가 생성될 것이다(비동기식으로)</li>
<li>204 No Content - 뷰를 업데이트할 필요가 없음</li>
<li>205 Reset Content - 클라이언트가 뷰를 재설정해야 한다</li>
<li>206 Partial Content - 반환된 부분 콘텐츠 (예 : 구간 설정된 혹은 페이지 별 콘텐츠)</li>
<li>400 Bad Request - 요청이 잘못되었음</li>
<li>401 Unauthorized - 클라이언트가 서버에 인증되지 않음</li>
<li>403 Forbidden - 클라이언트는 서버에 인증되었지만 요청된 자원에 대해 요청된 작업을 수행할 수있는 권한이 없음</li>
<li>405 Method Not Allowed - 요청된 URL에 사용된 HTTP 메소드가 허용되지 않음</li>
<li>409 Conflict - 작업을 수행할 때 충돌이 발생함. 예를 들어 요청이 이미 변경된 자원을 업데이트하려고 시도함</li>
<li>500 Internal Server Error - 서버의 오류가 발생했으나 처리되지 않음</li>
<li>501 Not Implemented - 요청된 자원에 대해 HTTP 메소드가 현재 구현되지 않음</li>
<li>503 Service Unavailable - 서버 또는 그것의 종속성 중 하나(예 : 데이터베이스)가 과부하, 정전 등으로 인해 응답 할 수 없음</li>
</ul>
</li>
</ul>
<h4 id="Example-Doctors-Office-API"><a href="#Example-Doctors-Office-API" class="headerlink" title="Example: Doctors Office API"></a>Example: Doctors Office API</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resource API Endpoints:</span><br><span class="line"></span><br><span class="line">GET    /customers</span><br><span class="line">POST  /customers</span><br><span class="line">GET    /customers/&lt;id&gt;</span><br><span class="line">PUT    /customers/&lt;id&gt;</span><br><span class="line">PATCH  /customers/&lt;id&gt;</span><br><span class="line">DELETE /customers/&lt;id&gt;</span><br><span class="line">GET    /customers/&lt;id&gt;/appointments</span><br><span class="line">POST  /customers/&lt;id&gt;/appointments</span><br><span class="line">GET    /customers/&lt;id&gt;/appointments/&lt;id&gt;</span><br><span class="line">PUT    /customers/&lt;id&gt;/appointments/&lt;id&gt;</span><br><span class="line">PATCH  /customers/&lt;id&gt;/appointments/&lt;id&gt;</span><br><span class="line">DELETE /customers/&lt;id&gt;/appointments/&lt;id&gt;</span><br><span class="line">GET    /customers/&lt;id&gt;/cell_phone</span><br><span class="line">PUT    /customers/&lt;id&gt;/cell_phone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Asynchronous Task Queue API Endpoints:</span><br><span class="line"></span><br><span class="line">GET    /outgoing-emails</span><br><span class="line">POST  /outgoing-emails</span><br><span class="line">GET    /outgoing-emails/&lt;id&gt;</span><br><span class="line">PUT    /outgoing-emails/&lt;id&gt;</span><br><span class="line">PATCH  /outgoing-emails/&lt;id&gt;</span><br><span class="line">DELETE /outgoing-emails/&lt;id&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Synchronous Agent API Endpoints:</span><br><span class="line"></span><br><span class="line">GET    /patient-discharger</span><br><span class="line">GET    /patient-discharger/&lt;id&gt;</span><br><span class="line">POST  /patient-discharger</span><br><span class="line">DELETE /patient-discharger/&lt;id&gt;</span><br></pre></td></tr></table></figure>
<h4 id="더-읽을-거리"><a href="#더-읽을-거리" class="headerlink" title="더 읽을 거리"></a>더 읽을 거리</h4><ul>
<li>아래와 같은 사이트는 모범사례로써가 아닌 RESTful API에 대한 혼란을 일으키는 사례로 포함시킨다<ul>
<li><a target="_blank" rel="noopener" href="http://www.bitnative.com/2012/08/26/how-restful-is-your-api/">http://www.bitnative.com/2012/08/26/how-restful-is-your-api/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#method-override">http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api#method-override</a></li>
<li><a target="_blank" rel="noopener" href="http://vvv.tobiassjosten.net/development/your-api-is-not-restful/">http://vvv.tobiassjosten.net/development/your-api-is-not-restful/</a></li>
<li><a target="_blank" rel="noopener" href="https://mmikowski.github.io/the_lie/">https://mmikowski.github.io/the_lie/</a><ul>
<li>반가운 얼굴이다!</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="미신"><a href="#미신" class="headerlink" title="미신"></a>미신</h2><p>여기부터는 REST를 알지 못하는 사람들을 이해해보려 좀 더 검색한 내용을 적어볼텐데, 대단한 근거는 없다.</p>
<p>나는 그토록 뛰어난 개발자들이, 게다가 영어권에 살면서 얼마든지 로이의 논문을 비오는 일요일 오후에 슬쩍 읽어볼 수 있을 사람들이 왜 이렇게 일관된(?) 오해를 하고 있는지 궁금했다.</p>
<p>그 기원을 좀 더 찾아보려고 뒤져본 바, ROA(Resource-Oriented Architecture)에서 찾을 수 있었다.</p>
<p>앞에서 잠시 언급했던 <a target="_blank" rel="noopener" href="http://greatkim91.tistory.com/13">행복한 아빠</a>님의 블로그를 보자.</p>
<blockquote>
<p>REST(Representational State Transfer)는 HTTP의 주요 저자인 Roy Fielding의 2000년 논문에 의해 소개가 된 네트워크 아키텍처를 위한 구조이다. REST가 화두가 되면서 RET의 정체를 알아보기 위해 “RESTfull Web Services”를 읽고 이 책에서 말하는 Resource-Oriented Architecure(이하 ROA)를 나름대로 정리해 보았다.</p>
<p>ROA는 REST 기반(이하 RESTful) 웹서비스를 만들기 위한 문제점을 해결하는 방법을 제공한다.<br>ROA는 RESTful 아키텍처이다.</p>
</blockquote>
<p>(충분히 못 찾은 것일 수도 있지만) 난 2008년도에 쓰인 이 글이 한국어로 된 것 중에 REST에 대해 이해하기 가장 좋은 글이라고 생각한다.</p>
<p>이 분이 공부했다는 것이 Leonard Richardson의 <a target="_blank" rel="noopener" href="http://shop.oreilly.com/product/9780596529260.do">RESTful Web Services</a>인데<br><a target="_blank" rel="noopener" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788956744193">한국어 번역서</a>은 절판 상태.</p>
<p>대신 마틴 파울러가 <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/richardsonMaturityModel.html">이를 소개한 블로그</a>를 썼는데, 마침 지앤선이 <a target="_blank" rel="noopener" href="http://jinson.tistory.com/190">번역</a>을 해놓았다(중간중간 이해하기 어려운 문장이 보인다면 원문을 참조하기 바란다).</p>
<p>여기까지 와도 아직 REST가 잘못 이해되진 않았다. 제대로 이해하고 구현하려는 시도로 보인다.</p>
<p>위에 소개한 “Your API isn’t RESTful — And That’s Good”에서 언급된 대로,</p>
<p>REST를 이루기 위한 여러 복합적인 요소&#x2F;방법 중 자신의 결과물과 몇 가지 구현상의 공통점을 발견하고 REST란 용어만 납치했다고 봐야할 것 같다.</p>
<p>구현하기 쉬운 부분만 골라서 best practice set이 만들어진 게 아닐까.</p>
<p>하나만 기억하자,</p>
<p>서버와 클라이언트가 서로의 눈치를 보며 변화&#x2F;발전을 두려워 하고 있다면(즉, 서로에게 강한 의존성을 갖고 있다면),</p>
<p>그건 REST가 아니다.(하지만 괜찮다. REST라고 안 부르면 되니까.)</p>
<p>서버와 클라이언트는 변화에 대응하기 위해 프로토콜&#x2F;표준을 통한 약한 의존성을 가져야 한다.</p>
<p>아니 이건 수십년 간 소프트웨어 엔지니어링이 강조하고 있는 것이 아닌가!</p>
<p>마지막으로 아래의 관점도 생각해볼 만 하다.</p>
<p><a target="_blank" rel="noopener" href="https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling">REST API Design - Resource Modeling</a></p>
<ul>
<li>현실적으로 REST API를 어떻게 다루어야 하는지 이야기하고 있다</li>
<li>“REST without PUT”이라고도 하는 기법은, 상태 변화를 위한 요청(mutation)에서 PUT을 통한 새로운 상태를 전송하지 않고, 상태 변화 자체를 리소스로 올려first class citizen noun) 사용하자는 의미이다. </li>
<li>예를 들어, 고객 주소를 갱신할 때의 대상 리소스는 customer가 아닌 ChangeOfAddress라고 정의한다 </li>
<li>이것이 CQRS 적용에 있어 부가적인 효과를 얻을 수 있다고도 하지만, 내가 CQRS나 이벤트 소싱을 알지 못하기 때문에 더 이상의 언급은 피해야겠다</li>
<li>다만 앞으로 다룰 예정인 GraphQL을 이 관점에서 바라보면 재미있을 것 같다</li>
</ul>
<h2 id="끝"><a href="#끝" class="headerlink" title="끝"></a>끝</h2><p>혹시라도 이 긴 여정을 충실히 따라오신 독자가 있다면, 진심으로 고마움과 존경을 표한다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/06/26/rest-the-truth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/06/26/rest-the-truth/" class="post-title-link" itemprop="url">REST - Roy가 입을 열다</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-06-26 00:41:41" itemprop="dateCreated datePublished" datetime="2017-06-26T00:41:41+09:00">2017-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/06/26/rest-the-truth/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/26/rest-the-truth/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="Untangled"><a href="#Untangled" class="headerlink" title="Untangled"></a>Untangled</h2><p>‘RESTful APIs, the big lie’의 댓글 마지막 쯤 누군가 추천해 준 컨텐츠 몇 개를 소개해본다.</p>
<p><em>(이번에도 여전한 오역과 거친 의역에 대해 양해를 구하며…)</em></p>
<p>우선 당사자인 Roy 자신이 쓴 글이 꽤 재미있다.</p>
<p>“REST APIs must be hypertext-driven”이란 글이 꽤 유명한 것 같지만</p>
<p>이것 말고도 Roy가 2008년도에 <a target="_blank" rel="noopener" href="http://roy.gbiv.com/untangled/tag/rest">REST에 관해 쓴 글</a>을 보면 각기 나름의 재미가 있다. </p>
<p>예를 들어 이런 글, “POST 써도 괜찮아”</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post">http://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post</a><ul>
<li>Tim Bray란 사람이 Sun Cloud용 API를 공개했을 때, 어떤 이가 왜 새로운 VM을 띄우는 데 POST를 사용하냐는 질문이 있었고 이에 대한 설명을 블로그로 남겼다.<br>  재부팅할 때는 상태도 계속 변화하고, 뭔가 내부적으로 많은 일이 일어나는데 이때 POST를 쓰겠다는 이야기가 나온다.</li>
<li>Roy도 여기에 자신도 POST를 쓰겠다는 이야기를 한다.<br>  REST의 논문에선 CRUD에 대한 언급을 안 했으며, 모든 자원에 대해 균일하게 정의되어야 한다 정도를 언급했다. 다만 이 메소드가 본래의 정의에 맞게 사용되기는 해야한다. 모든 상태변화에 PUT만 쓸 필요가 없다.<br>  POST는 다른 메소드와 다르게 캐시나 중개자의 오류처리 등을 위한 방법은 제공하지 않지만 여전히 유용한 메소드이다.<br>  자신은 그 리부팅을 위한 버튼에는 POST만 쓸 것이고, 클라이언트가 그 응답으로부터 상태가 변경됐음을 알 수 있도록 함으로써 POST의 부족한 사용성을 보완할 수 있게하겠다..고 했다.</li>
</ul>
</li>
</ul>
<h2 id="REST-APIs-must-be-hypertext-driven"><a href="#REST-APIs-must-be-hypertext-driven" class="headerlink" title="REST APIs must be hypertext-driven"></a>REST APIs must be hypertext-driven</h2><p>그 유명한 “<a target="_blank" rel="noopener" href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">REST APIs must be hypertext-driven</a>“(REST API는 hypertext가 주도해야만 해)를 읽어보자.</p>
<h3 id="요점-정리"><a href="#요점-정리" class="headerlink" title="요점 정리"></a>요점 정리</h3><p>난 사람들이 HTTP기반의 인터페이스를 REST API라고 부르는 것이 실망스럽다. “SocialSite REST API”라고 부르는, 그건 RPC다</p>
<ul>
<li>현재 링크는 사라졌으나, 결국 <a target="_blank" rel="noopener" href="https://www.w3.org/blog/2014/12/opensocial-foundation-moves-standards-work-to-w3c-social-web-activity/">https://www.w3.org/blog/2014/12/opensocial-foundation-moves-standards-work-to-w3c-social-web-activity/</a> 여기를 의미함</li>
</ul>
<p>API가 hypertext 주도로 동작하지 않는다면, RESTful하지 않고 REST API가 아니다. 어디 잘못된 매뉴얼이라도 돌아다니는 거야?</p>
<p>API 디자이너들은 당신의 창작물을 REST API라고 부르기 전에 아래 규칙들을 확인하기 바란다</p>
<ul>
<li>REST API는 어떤 특정 통신 프로토콜에 종속되면 안 된다<ul>
<li>일반적으로 URI를 식별자로 사용하는 프로토콜 요소는 URI를 식별하기 위해 어떤 URI scheme이든 허용해야 한다</li>
<li>실패하는 경우 : 식별 기능이 interaction과 분리되지 않을 때 실패한다</li>
</ul>
</li>
<li>REST API는 표준화되지 않은 프로토콜의 일부를 채우거나 수정하는 것을 제외하면, 프로토콜 자체에 수정을 가해서는 안 된다<ul>
<li>잘못된 구현(HTML이 HTTP 메소드를 정의하고 있다고 믿을 정도로 멍청한 브라우저들 같은)에 관한 해결방법은 별도로 분리해야한다. (그게 결국 쓸모없게 될 것을 가정하고)</li>
<li>실패하는 경우 : 리소스 인터페이스가 포괄적인 의미가 아닌 오브젝트에 종속되는 경우 실패한다</li>
</ul>
</li>
<li>REST API는 이를 설명하려는 대부분의 노력을, 리소스의 representation과 어플리케이션의 상태를 주도할 media type 이나, 존재하는 media type을 활용해 hypertext가 가능한 마크업이나 관계를 정의하는데 써야 한다<ul>
<li>어떤 상황의 URI엔 어떤 메소드를 써야한다고 정의하는데 쓰는 노력은 media type을 처리하는 규칙의 범위 안에 완전히 정의되어야 한다</li>
<li>실패하는 경우 : hypertext 대신, 서버와 클라이언트 간 주고받는 범위 밖의 정보(out-of-band information)를 통해 인터렉션을 주도하면 실패한다</li>
</ul>
</li>
<li>REST API는 고정된 리소스나 계층구조를 고정해서는 안 된다(client와 server 간 명백한 결합이다)<ul>
<li>서버는 반드시 스스로의 namespace를 제어할 수 있는 자유가 있어야 한다. 대신 client에게 어떻게 URI를 구성해야할 지 알려주도록 하자. HTML form이나 URI Template에서 동작하는 방식으로, media type과 link relation을 통해</li>
<li>실패하는 경우 : client가 (RPC의 기능적 결합에 해당하는 데이터 지향적인) domain-specific 표준 같은 것으로부터 리소스 구조를 추측하게 만들 때</li>
</ul>
</li>
<li>REST API는 client에 중요한 리소스에 type을 지정해서는 안 된다<ul>
<li>명세를 만드는 사람들은 인터페이스 뒷단의 서버 구현체를 묘사하기 위해 resource type을 사용할 지도 모른다. 하지만 그런 타입은 client에게 불필요하고 보이지 않는다</li>
<li>client에게 중요한 단 하나의 타입은 현재 representation의 media type과 표준화된 relation 이름 뿐이다</li>
</ul>
</li>
<li>REST API는 초기 URI (bookmark) 및 의도된 대상에게 적합한 표준화 된 미디어 유형 세트 이외에는 사전 지식없이 입력해야한다. 그걸 사용할 client가 이해할 수 있도록<ul>
<li>이 관점에서, 모든 어플리케이션 상태의 전이는 서버가 제공한 선택지 안에서 client의 선택으로부터 주도돼야 한다. 그 선택지는 전달받은 representation 안에 있거나 이를 client가 조작한 것에서 나와야 한다</li>
<li>상태 전이는 client의 media type이나 리소스 교환 메커니즘에 대한 지식에 의해 결정되거나 제한될 수 있다</li>
<li>실패하는 경우 : hypertext 대신, 서버와 클라이언트 간 주고받는 범위 밖의 정보를 통해 인터렉션을 주도하면 실패한다</li>
</ul>
</li>
</ul>
<h3 id="댓글"><a href="#댓글" class="headerlink" title="댓글"></a>댓글</h3><p>Bjorg : 왜 hypermedia 대신 hypertext란 용어를 사용하는가?</p>
<ul>
<li>로이: <ul>
<li>hypermedia에 대한 정의는 매우 다양하다</li>
<li>Ted Nelson의 원래의 정의에선 비선형 문서에 초점을 맞췄다</li>
<li>이후 특정 UI 메커니즘으로 설명되고 있다</li>
<li>내가 hypertext라고 이야기 하는 건, 정보와 통제(control)를 동시에 제공함으로써, 그 정보가 사용자에 선택권을 주고 동작을 결정하는 수단이 되는 것을 말한다</li>
<li>hypertext는 브라우저 위에서 HTML로 이루어질 필요는 없다. 기계는 data format과 relation type만 이해하면 링크를 따라갈 수 있다</li>
</ul>
</li>
</ul>
<p>SocialSite REST API에 대해 쓴 블로거(snoopdave)가 와서 댓글을 달았고, 로이가 그건 여전히 RPC 결과를 wrapping한 것 뿐이라고 반박한다</p>
<ul>
<li>매번 하는 이야기인 media type, relation, 사용자의 선택권 같은 이야기를 하는데, 정확히 번역하기 어려움</li>
</ul>
<p>BillHiggins : 사람들이 자신이 REST를 만든다고 생각하는 이유는 뭐라고 생각해, 로이?</p>
<ul>
<li>로이: <ul>
<li>일부는 내가 논문에서 media type 설계에 대한 세부사항을 충분히 넣지 못했기 때문인 것 같아. 그건 시간이 부족했기 때문이지, REST의 다른 부분에 비해 중요하지 않아서가 아니야</li>
<li>마찬가지로 많은 사람들이 권위있는 출처를 기반으로하지 않는 Wikipedia 항목 만 읽었기 때문이기도 하다</li>
<li>그러나, 사람들은 단순한 것을 디자인하기 위해 단순하게 생각하는 건 실수라고 생각한다. 무언가를 설계한다는 것은 결과의 단순함과는 반비례한다</li>
<li>REST의 모든 세부사항은 소프트웨어의 수명과 독립적인 진화를 촉진하기 위함이다</li>
<li>많은 제약사항은 단기 효율에 직접적으로 거부하고 있다</li>
<li>사람들은 단기적 설계에는 능숙해도 장기적 설계에는 형편없으며, 현재의 릴리즈 이후의 설계를 하지않는다</li>
</ul>
</li>
</ul>
<p>nkallen : 내가 생각하는 게 맞는 지 좀 알려줘.</p>
<ul>
<li>행위는 media type에 의해 결정된다. 그렇다면 GET &#x2F; POST &#x2F; PUT &#x2F; DELETE는 미디어 유형에 따라 의미가 부여되는가<ul>
<li>로이: <ul>
<li>모든 media type은 기본 동작 방식이 정의되어 있다. 그건 GET &#x2F; POST &#x2F; PUT &#x2F; DELETE와 같은 메소드와 전혀 상관없다</li>
<li>식별자, 메소드, media type은 관심사가 교차하지만 메소드는 media type으로부터 의미가 부여되지 않는다</li>
<li>대신 media type은 client에 어떤 메소드를 사용할 지 결정하는 방법을 알려준다</li>
</ul>
</li>
</ul>
</li>
<li>조작을 위한 인터페이스는 발견되어야 한다. 예를 들어, 이미지 리사이즈를 위해 width,height를 파라미터로 넘기는 등<ul>
<li>로이: 발견될 필요는 없다. 그건 이미 hypertext안에 존재하니까. representation은 어플리케이션의 다음 상태로 가기 위한 모든 변화를 어떻게 만들어 낼지 알려준다</li>
</ul>
</li>
<li>root resource로부터 하위 리소스로의 링크를 가져올 수 있어야 하는가? 우리는 하위 리소스의 위치를 미리 알아둘 필요는 없을 것 같다.  API 문서에 있으니까<ul>
<li>로이: 리소스 모델링의 목적은, 네가 식별하고 representing하고 조작할 가치가 있는 리소스를 찾아내기 위함이다. 리소스 이름 구조에 의존하는 client를 만들어선 안 된다</li>
</ul>
</li>
</ul>
<p>TheOtherMarcus: 리소스와 타입, 가능한 동작을 식별하는 유명한 hypertext media type을 하나 소개해줄 수 있을까? 내가 새로운 아이템을 추가하는 POST를 작성한다고 할 때, 어떤 미디어 타입이 적당한 지 어떻게 표현해야 하지?</p>
<ul>
<li>Roy :<ul>
<li>HTTP의 동작은 일반적이다. 리소스 별로 혀용되고 안되고 차이는 있지만 모두 사용 가능하다. hypertext는 네가 사용 가능한 모든 동작을 말해주진 않는다. 단지 각각 사용 가능한 동작이 무엇인지 말해줄 뿐이다. client는 어떤 인터페이스를 사용할 것인가가 아니라 어떤 작업을 할지를 결정하는 것이다</li>
<li>HTML은 type 명세가 필요없다. RESTful 설계도 그런 건 필요없다. POST가 어떤 의미인 지 네가 결정할 일은 없다. 그건 리소스가 정하는 거니까. 네 환경에서 이해할 수 있는 리소스 타입을 가진 hypertext representation이 POST의 결과로 어떤 걸 기대할 수 있는 지 알려준다.  HTTP 응답은 결과로서 어떤 일이 일어났는지 알려준다</li>
</ul>
</li>
</ul>
<p>jdubray : 보통 하이퍼텍스트는 특정 리소스에서 허용되는 모든 작업을 알려주지 않아. 잠재적인 전환을 알려줄 뿐이지. 이런 전환에 대한 정확한 사전 지식이  없다면 코드를 짜는 게 얼마나 어려울 지 상상이 가. 리소스의 생명 주기(상태, 전환 등)가 변경되었을 때도 내 코드가 문제가 없을지 어떻게 알겠어?</p>
<ul>
<li>Roy : <ul>
<li>물론 클라이언트는 사전 지식을 갖기 마련이고, 모든 프로토콜, 미디어 유형 정의, URI 스킴, link의 relation 유형들도 클라이언트가 알아야할 사전 지식 중 하나지. REST는 그 단서가 필요없다고 하진 않아. REST가 하는 일은 사전 지식의 필요성을 쉽게 표준화할 수 있는 형태로 집중하는 것이지. 이건 데이터 지향 - 컨트롤 지향 통합 간 주요한 차이이지</li>
<li>표현과 관계 유형을 표준화하는 것이 오브젝트와 오브젝트 특정 인터페이스를 표준화하는 것보다 쉽지. 알아야 할 것은 더 적고, 예상치 못한 방식으로도 재조직되면서도 여전히 클라이언트는 잘 이해할 수 있지</li>
<li>하지만 모든 사람들이 REST 설계 방식에 따라 자체 시스템을 재설계해야 한다고 생각하진 않아. REST는 여러 조직에 걸쳐있는 수명이 긴 네트워크 기반 응용 프로그램을 대상으로 하니까. 제약조건이 필요없다면 안 쓰면 돼. 다만 그걸 REST API라고는 하지 말아야지. 자신의 설계 스타일에 맞는 시스템에다가는 뭐라 하고 싶지 않아</li>
</ul>
</li>
</ul>
<p>tlainhart : 이 아키텍쳐 스타일에 대한 부정적인 반응 중 하나는 어떻게 그걸 효율적으로 구성할 수 있을까이다. 이를 위해 캐싱 서비스를 사용하는 것이 좋을 거라고 가정해도 될까? </p>
<ul>
<li>Roy :<ul>
<li>캐싱은 중요하고 바람직하지만, 배치 작업에는 잘 맞지 않지. 사람들은 리소스의 범위를 이해 못하기 때문에 배치 작업이 필요하다고 생각한다</li>
<li>리소스는 스토리지에 있는 항목과 항상 동일하진 않아. XML 처럼 동일한 자원 상태가 여러 자원으로 겹쳐질 수도 있지</li>
<li>마찬가지로 단일 리소스가 데이터베이스의 stored 프로시저와 동일할 수 있고, 이는 수많은 저장 항목에 대한 상태 변경을 추상화한 것일 수 있지</li>
<li>배치 작업이 필요하다고 생각이 들면, 리소스를 충분히 정의하지 않은 탓일 지도 몰라</li>
</ul>
</li>
</ul>
<p>TheOtherMarcus : </p>
<ul>
<li>내가 REST에 대한 내 생각을 말해보고 여전히 남아있는 모순에 대해 물어볼게</li>
<li>클라이언트가 하이퍼텍스트에 제시된 동작 중 하나를 골라 현재 응용 프로그램 상태를 변경했다고 하자</li>
<li>CreateItem POST &#x2F;random&#x2F;uri</li>
<li>클라이언트는 이 CreateItem가 뭔 지 알아야 하지. 이건 media type의 일부이니까</li>
<li>&#x2F;random&#x2F;uri를 POST로 보내면 새로운 프로그램 상태가 반환되지(201 응답)</li>
<li>역주) ….뭐 이런 내용이 나오는데 별로 중요하진 않음</li>
<li>Roy :<ul>
<li>응용 프로그램의 상태와 자원의 상태를 헷갈리면 안돼</li>
<li>그건 그렇고. 블로그 댓글 안에서 디자인에 대한 추가 지침을 줄 수는 없다고 생각해. 내 짐작으로는 네가 OOD나 ER 모델링을 리소스 공간에 투영하려는 것 같은데, 애플리케이션 요구 사항 및 컨텍스트에 대한 광범위한 지식 없이는 적절한 디자인이 뭔지 말할 수 없다</li>
</ul>
</li>
</ul>
<p>Robert Cernysays: 주어진 API가 RESTful한 지 알 수 있게, 또 글로만 적어줘서 고맙다. 지능이 발달한 인간이야 인터페이스의 추상적인 설명을 보고 REST인가를 결정할 수 있지만, 기계는 가능한가? 샘플 소스라도 좀 보내줄 수 있을까? 못 한다면, 왜?</p>
<ul>
<li>Roy :<ul>
<li>REST에 대한 추적 기준을 제공하기 여렵다면, 클라이언트가 전이를 결정하는 방법이 중요하다고 생각해라</li>
<li>명세를 테스트할 때 가정 어려운 부분은 RESTful 프로그램이 사실 대역 외 정보에 의존하고 있거나 작성자가 문서 작성 목적으로 지나치게 명세를 만들어 놓는 경우이다. 내가 찾는 건 미디어 유형에 대한 명세 밖에 정의된 어떤 행위에 대한 요구 사항이다. 가장 쉬운 예로는 프로토콜이 일반 미디어 유형을 요청하고 API 별로 특수하게 처리하는 경우를 들 수 있다. 그것들이 일반적인 형식의 의미를 확장하는 XML 네임스페이스 선언처럼 content 내에서 어떤 고유한 것을 강화하고 있다면 괜찮다. 그러나 일반적으로 OPENSOCIAL같은 애들이 하는 건, 응답 안에 미디어 유형에 의해 정의된 것 이상의 특정한 구조를 가지고 있다고 가정한다. 구조가 변경되면 클라이언트는 망가지겠지</li>
</ul>
</li>
</ul>
<p>30번 nkallen에 대한 답변</p>
<ul>
<li>Roy :<ul>
<li>미디어 유형은 representation이 어떻게 처리될 지에 정의하는 명세를 가리킨다. 이건 대역 외 정보가 맞고 모든 통신은 사전 지식에 의존하고 있다. 네가 놓치고 있는 것은 각각의 representation이 제공되는 서비스와의 특정 지침을 포함하고 있다는 사실이다. 미디어 유형이란 건 모든 에이전트가 배울 수 있는 일반적인 처리 모델이다. representation은 agent가 실행하는 어플리케이션에 따라 다르다. 따라서 각 representation은 어플리케이션의 해당 시점에서 사용할 수 있는 전환(transition)을 제공한다</li>
<li>representation이 relation이 지정된 hypertext로 제공된다면 agent는 사람과 다를 바 없이 이 어플리케이션을 따라갈 수 있다. 내게 중요한 건, 인간을 위한 좋은 웹 디자인이 반영된 동일한 디자인이다. 동일한 아키텍쳐 스타일로 기계와 인간 모두를 지원하는 프로토콜을 설계할 수 있다</li>
</ul>
</li>
</ul>
<p>역주) 이후 링크가 깨진 트랙백이 다수…</p>
<p>Dima : 공개된 API 중에 실제로 RESTful하다고 생각한 게 있어? 내가 가진 문제는 보안을 수행하며 동시에 RESTful하게 유지하는 것이야. 보안이 필요한 요청을 보낼 때는 보통 이렇게 하지.  GET &#x2F;resource&#x2F;11231231&#x2F;token&#x3D;KJGHY7687JKGH. POST를 쓰지 않는 한, 이보다 더 좋은 방법이 있을까?</p>
<ul>
<li>Roy :<ul>
<li>난 네가 그런 모호한 URI 형식이 보안이 필요한 요청을 가능하게 한다고 생각하는 지 잘 모르겠어. RESTful 시스템은 다른 메시지 전송 프로토콜과 동일한 방식으로 안전한 동작을 하고 있어. 메시지 스트림을 캡슐화하거나 메시지 자체를 암호화 하면서 말이지. 실제로 많은 예제가 존재하고, 브라우저가 다른 인증 메커니즘을 익히면 더 많이 생기겠지</li>
</ul>
</li>
</ul>
<p>역주) 이후엔 Roy의 답변이 없고, 블로그 몇 개를 더 썼다. 아래 colinjack이란 사람이 한 말은 의미있다</p>
<p>colinjack  : DDD와 비교를 하면서, DDD도 오해를 겪고 사람들은 때로 중요하지 않은 부분에 집중을 하지만, Evans의 책이 살아있는 예제를 제공하고 그의 아이디어가 왜 중요한지를 보여준다. 그러나 REST에서는 웹에 많은 컨텐츠가 있지만, REST 전문가가 썼다 하더라도 새로 접하는 사람들에게는 거의 쓸모가 없다. 사실 좋은 REST 예제와 토론은 줄어들고 있고, 아마도 이런 REST라는 용어를 납치하게 된 이유가 된 것 같아. <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/webber-rest-workflow#anch33051">여기</a>에서 (RESTful하진 않지만) 현실적인 예제가 있긴 하다. (이 링크의 댓글을 보면 ‘REST’에서 ‘RE’는 빼고 ‘ST’에 대한 좋은 글이라는 비아냥이 있다)</p>
<h2 id="REST-I-don’t-Think-it-Means-What-You-Think-it-Does"><a href="#REST-I-don’t-Think-it-Means-What-You-Think-it-Does" class="headerlink" title="REST: I don’t Think it Means What You Think it Does"></a>REST: I don’t Think it Means What You Think it Does</h2><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=pspy1H6A3FM">GOTO 2014 • REST: I don’t Think it Means What You Think it Does • Stefan Tilkov</a></p>
<p>이것도 ‘RESTful APIs, the big lie’의 댓글에서 추천을 받은 동영상이다.</p>
<p>‘그건 REST가 아니야’류의 발표나 글은 참 많은데, 제대로 REST를 이야기하는 몇 안 되는 강연 중 하나라고 생각한다.</p>
<h4 id="REST의-주요-특징"><a href="#REST의-주요-특징" class="headerlink" title="REST의 주요 특징"></a>REST의 주요 특징</h4><ul>
<li>URI를 통해 식별하고</li>
<li>Representation을 통해 실제 데이터와 전달받는 정보를 분리</li>
<li>흐름을 제어하기 위해 hypermedia를 활용</li>
<li>self-descriptive한 메시지<ul>
<li>표준화된 방식으로 메타데이터를 통해 전달함으로써 캐싱 등의 이점이 있다</li>
<li>나머지는 제대로 요약을 못하겠음…</li>
</ul>
</li>
</ul>
<h4 id="REST-미신"><a href="#REST-미신" class="headerlink" title="REST 미신"></a>REST 미신</h4><p>REST는 좋은 URL에 관한 것이다 -&gt; 땡</p>
<ul>
<li>RESTful한 URI 같은 건 없다</li>
<li>중요한 건 hypermedia context<ul>
<li>그 URI가 client에게 어떻게 노출되는가</li>
<li>서버는 지가 알아서 잘 한다</li>
</ul>
</li>
</ul>
<p>REST &#x3D; URI 패턴 + GET, PUT, POST, DELETE -&gt; 비슷하지만, 땡</p>
<ul>
<li>&#x2F;customers&#x2F;{id}&#x2F;orders<ul>
<li>주문을 하기위해 회원 URI에 &#x2F;orders를 붙이는 것보다는 &#x2F;customers&#x2F;{id}의 응답 안에 주문을 할 수 있는 링크를 넣어주는 게 좋다</li>
</ul>
</li>
<li>&#x2F;v1&#x2F;이런 버저닝은 바보같은 짓이다 하지말자!<ul>
<li>Data는 괜찮다. document도 괜찮다. 그것도 data니까</li>
<li>하지만 API에서는 버저닝은 아무 쓸모가 없다. 그 버전이 얼마나 자주 바뀌는 것 같아? API의 정체성은 거의 바뀌지 않는다. 버전을 URI에 넣는다는 것은 API가 아무 이유없이 계속 바뀐다는 의미로 보인다</li>
<li>버전이 바뀐다는 것은 URI 구조가 깨진다는 의미이다</li>
<li>버저닝을 하고 싶을 때<ul>
<li>다른 것을 리턴하고 싶으면 다른 미디어타입을 사용할 것</li>
<li>URI에 버전을 넣고 싶으면 리소스 자체에 버전을 매겨라. document 같이</li>
<li>API에 새로운 관점이 생긴다면 새로운 리소스를 만들어라. 새로운 걸 만들고 링크를 걸어라. 그게 웹이 잘하는 거잖아</li>
<li>링크를 위한 공간을 확보할 것</li>
<li>API가 아닌 document에 버저닝을 할 것</li>
<li>청중의 질문 : 그럼 헤더에 버전을 심어서 쓰는 건 어떤가?<ul>
<li>괜찮다. 네 회사 안에서나 한정된 곳에서는 self-descriptive하고 좋다. 그런데 그건 표준화된 건 아니다. 그래서 누군가 그걸 빼먹거나 이해 못할 가능성이 있다</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>안정적인 API를 위해 지켜야할 것<ul>
<li>Client<ul>
<li>URI 구조에 의존하지 말것</li>
<li>모르는 링크를 지원하고 모르는 컨텐츠는 무시할 것</li>
<li>새로운 링크에 대해선 열려있어야 하고, 내가 모르는 필드가 추가됐다면 그냥 무시하면 된다. API는 바뀌기 마련이니</li>
</ul>
</li>
<li>Server<ul>
<li>의미없이 URI 구조를 무너뜨리지 마라</li>
<li>추가 리소스를 통해 진화하라</li>
<li>오래된 양식을 지원하라</li>
</ul>
</li>
</ul>
</li>
<li>어떻게 hypermedia-enable할 수 있는가?<ul>
<li>Step 1. service document<ul>
<li>서비스&#x2F;페이지에서 필요한 링크를 모아놓은 문서</li>
<li>JSON Home<ul>
<li>이런 문서도 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/draft-nottingham-json-home-03">표준화</a>가 진행중</li>
<li>application&#x2F;json-home</li>
</ul>
</li>
</ul>
</li>
<li>Step 2. resource links<ul>
<li>애초에 리소스 자체에 필요할 수 있는 링크를 추가하기</li>
</ul>
</li>
<li>Step 3. state transition links<ul>
<li>어플리케이션의 상태에 따라 필요한 링크를 정해주기</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>hypermedia apis &#x3D; Responses with links -&gt; 그게 다가 아니다<br>    * Rule #1. Don’t have clients build URIs using string concatenation<br>        * 대신, 레시피를 제공하라. 이것도 역시 hypermedia이다.<br>        * 다음에 요청할 URI를 만들 수 있는 템플릿을 제공<br>        * 이것도 표준이 있다 : <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6570">https://tools.ietf.org/html/rfc6570</a><br>        * 여기서 더 나아가면 default data를 제공하는 폼을 만들 수 있다. (<a target="_blank" rel="noopener" href="https://youtu.be/pspy1H6A3FM?t=2602">43:20 지점</a>)</p>
<p>REST &#x3D; 서비스 인터페이스에 대한 색다른 접근 방식 -&gt; 너무 단순한 표현이다</p>
<ul>
<li>우리는 다수의 client가 다수의 server에 접근하는 서비스 인터페이스를 만드는데, 이때 특정 서버에 종속되지 않은 hypermedia 타입을 만들어야 한다.</li>
<li>그러기 위해선 아래와 같은 표준을 사용할 수도 있다<ul>
<li>application&#x2F;atom+xml</li>
<li>application&#x2F;vnd.collection+json</li>
</ul>
</li>
<li>그런데 그냥 text&#x2F;html을 쓰면 어떨까<ul>
<li>여기저기 퍼져있고</li>
<li>잘 알려져있고, hypermedia control을 잘 지원하고</li>
<li>좋은 표준 client가 존재하고</li>
<li>좋은 프로그래밍 tool이 존재한다</li>
<li>UI는 부수효과로 누릴수도 있고</li>
</ul>
</li>
</ul>
<p>이번에도 별로 대단한 걸 얻은 것 같진 않다면 바로 결론으로 넘어가자. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/06/12/rest-the-big-lie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/06/12/rest-the-big-lie/" class="post-title-link" itemprop="url">REST - REST 좋아하시네</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-06-12 20:41:23" itemprop="dateCreated datePublished" datetime="2017-06-12T20:41:23+09:00">2017-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/06/12/rest-the-big-lie/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/12/rest-the-big-lie/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="RESTful-APIs-the-big-lie"><a href="#RESTful-APIs-the-big-lie" class="headerlink" title="RESTful APIs, the big lie"></a>RESTful APIs, the big lie</h2><p>이제 개발자들 사이에 널리 퍼진 REST에 대한 오해를 들춰볼 차례이다.</p>
<p>독자 입장에선 이 정성으로 그냥 논문을 읽지 그러냐는 의문도 들 수 있겠지만,</p>
<p>이 바닥의 수많은 오해를 발견하는 재미도 있었다.</p>
<h2 id="REST에-관한-끊이지-않는-논쟁"><a href="#REST에-관한-끊이지-않는-논쟁" class="headerlink" title="REST에 관한 끊이지 않는 논쟁"></a>REST에 관한 끊이지 않는 논쟁</h2><p>자신을 “SPA (UI&#x2F;UX&#x2F;server) architect and author”라고 소개하고 있는<br><em>Michael S. Mikowski</em>의 <a target="_blank" rel="noopener" href="https://mmikowski.github.io/the_lie/">RESTful APIs, the big lie</a>라는 자극적인 글과 댓글을 읽고 한번 정리해볼 필요가 있다고 생각했다.</p>
<p>댓글로 달려드는 모두가 REST나 API를 바라보는 관점이 다르고, 댓글을 읽으면서 ‘그래, 그렇지’하면서 나의 관점도 계속 흔들렸다.</p>
<p>내가 흔들렸던 이유는 이 글을 읽을 때는 막 REST에 대해 공부하기 시작했을 때였기도 했고, RESTful한 API를 만들기 위한 현실적인 고민들이 남일 같지 않았기 때문이기도… </p>
<p>그냥 REST라는 용어만 포기하면 편하다는 결론은 내 후속 블로그 글에서 다시 확인하시고, 일단 개싸움부터 들여다보자.</p>
<p>사실 블로그 자체는 REST를 이해하는데는 별로 도움이 안 되는 글이긴 한데, 이런 개싸움이야 말로 진짜 현실 세계(반 REST 진영이 가장 많이 언급하는 단어가 ‘real world’이다)의 문제인 듯!</p>
<p>주요 논점을 정리해보고, 딸린 댓글을 개발 새발 정리한 버전은 페이지 마지막에 붙여놓겠다.</p>
<h2 id="블로그-본문"><a href="#블로그-본문" class="headerlink" title="블로그 본문"></a>블로그 본문</h2><p>우선 블로그에서 저자가 주장하는 바를 짧게 정리해보자.</p>
<h3 id="Problem-1-There-is-little-agreement-on-what-a-RESTful-API-is"><a href="#Problem-1-There-is-little-agreement-on-what-a-RESTful-API-is" class="headerlink" title="Problem #1: There is little agreement on what a RESTful API is"></a>Problem #1: There is little agreement on what a RESTful API is</h3><p>HTTP 메소드와 응답코드는 모호해서 그 뜻이 정확히 뭘 의미하는지 사람마다 다르게 인식한다.</p>
<p>어떤 응답코드를 줄 지는 회사&#x2F;사람마다 다른 기준이 있을 수 있어서, client 입장에선 정확히 예측하기 어렵다.</p>
<h3 id="Problem-2-The-REST-vocabulary-is-not-fully-supported"><a href="#Problem-2-The-REST-vocabulary-is-not-fully-supported" class="headerlink" title="Problem #2: The REST vocabulary is not fully supported"></a>Problem #2: The REST vocabulary is not fully supported</h3><p>브라우저는 PUT과 DELETE같은 문법을 지원하지 않는다.</p>
<p>307 Temporary 같은 애들은 브라우저마다 상이하게 처리되기도 한다. 제대로 지원하는 건 200과 500뿐이다.</p>
<h3 id="Problem-3-The-REST-vocabulary-is-not-rich-enough-for-APIs"><a href="#Problem-3-The-REST-vocabulary-is-not-rich-enough-for-APIs" class="headerlink" title="Problem #3: The REST vocabulary is not rich enough for APIs"></a>Problem #3: The REST vocabulary is not rich enough for APIs</h3><p>HTTP의 문법은 풍부하지 못해서 모든 어플리케이션의 요청과 응답을 표현할 수 없다.</p>
<h3 id="Problem-4-RESTful-APIs-are-very-hard-to-debug"><a href="#Problem-4-RESTful-APIs-are-very-hard-to-debug" class="headerlink" title="Problem #4: RESTful APIs are very hard to debug"></a>Problem #4: RESTful APIs are very hard to debug</h3><p>그래서 REST로 통신할 때 문제가 생기면 7가지나 되는 조합으로 원인을 파악해야 한다.</p>
<ul>
<li>HTTP method (GET&#x2F;POST)</li>
<li>URI</li>
<li>실제로 사용하고 싶은 HTTP method (PUT&#x2F;DELETE..) in payload</li>
<li>진짜 메시지 in payload</li>
<li>응답코드</li>
<li>진짜 받아야 하는 응답코드 in payload </li>
<li>진짜 메시지 in payload</li>
</ul>
<p>이런 한계 때문에 어떤 문제가 발생했을 때, 디버깅을 위해 고려해야할 게 너무나 많다.</p>
<h3 id="Problem-5-RESTful-APIs-are-usually-tied-to-HTTP"><a href="#Problem-5-RESTful-APIs-are-usually-tied-to-HTTP" class="headerlink" title="Problem #5: RESTful APIs are usually tied to HTTP"></a>Problem #5: RESTful APIs are usually tied to HTTP</h3><p>HTTP에 너무 종속되어 있다.<br>HTTP가 아닌 다른 전송 방식으로 전환하려면 또 저 7가지 조합을 고려해서 만들어야 한다.</p>
<h3 id="The-way-forward-JSON-Pure-APIs"><a href="#The-way-forward-JSON-Pure-APIs" class="headerlink" title="The way forward: JSON-Pure APIs"></a>The way forward: JSON-Pure APIs</h3><p>그래서 제안하는 건, JSON-Pure APIs</p>
<ul>
<li>이 글이 쓰인 지 3주 후 JSON-Pure APIs에 관한 <a target="_blank" rel="noopener" href="https://mmikowski.github.io/json-pure/">후속 블로그</a>가 올라온다</li>
</ul>
<h2 id="논쟁"><a href="#논쟁" class="headerlink" title="논쟁"></a>논쟁</h2><p>블로그 본문과 댓글에서 발화한 여러 논쟁을 크게 묶어 정리해본다.</p>
<h3 id="HTTP-메소드와-응답코드는-모호해서-그-뜻이-정확히-뭘-의미하는지-사람마다-다르게-인식한다"><a href="#HTTP-메소드와-응답코드는-모호해서-그-뜻이-정확히-뭘-의미하는지-사람마다-다르게-인식한다" class="headerlink" title="HTTP 메소드와 응답코드는 모호해서 그 뜻이 정확히 뭘 의미하는지 사람마다 다르게 인식한다."></a>HTTP 메소드와 응답코드는 모호해서 그 뜻이 정확히 뭘 의미하는지 사람마다 다르게 인식한다.</h3><p>따지고 보면 그걸 모르는 사람의 문제지만, 현실적으로는 이해가 되는 부분도 있다.</p>
<p>어떤 응답 로직을 구현하기 위해 적합성 여부를 여러번 생각해야하는 것은 어쨌든 일종의 비용이라고 생각한다.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://1ambda.github.io/javascripts/rest-api-put-vs-post/">https://1ambda.github.io/javascripts/rest-api-put-vs-post/</a> <ul>
<li>여기서 response code decision tree를 볼 수 있을 것이다<br><img src="http://i.stack.imgur.com/whhD1.png" alt="response code decision tree"></li>
</ul>
</li>
</ul>
<p>물론 이것은 REST의 문제가 아닌 구현상의 어려움일 뿐이다.</p>
<ul>
<li>이 글을 비판하는 진영에서는 ‘아니, 그게 왜 어렵다는 거야?’같은 반응을 보이기도 한다</li>
<li>사족이지만, npm 개발자인 <a target="_blank" rel="noopener" href="http://izs.me/">Isaac Z. Schlueter</a>는 세미콜론을 최대한 안 쓰는데, 이런 방식은 버그를 양산할 수 있고 혼란스러울 수 있다고 비판하는 사람들에게 ‘네가 JavaScript 문법을 몰라서 그렇다’고 일침하기도 했다</li>
</ul>
<p>요청 메소드와 응답 코드가 모든 상황을 담아낼 수 없다는 의견도 있는데, 이 글에 동조하는 사람들은 거대한 엔터프라이즈 환경(ERP, 병원 시스템 등)에서 다양하고 복합적인 리소스를 다루는 상황에 대해 언급한다.</p>
<p>논쟁을 지켜보며 생각이 드는 것은 - 추측이지만,</p>
<p>메소드가 충분치 않다는 감정은 특히 <a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C">RPC</a>를 실행하는 경우,<br>그러니까 내부적으로 복잡한 로직이 섞여있을 때 발생하는 것 같다. </p>
<p>예를 들어 리퀘스트를 날려서 설거지와 빨래와 아이 목욕을 시킨다면, 여기서 리소스란 무엇일까? 이 때는 어떤 메소드를 써야하는가?</p>
<p>이 지점부터 한차례 혼란이 오는 것 같은데, 그 리퀘스트를 보내는 대상 리소스가 우리가 흔히 인식하는 리소스, 그러니까 CSS나 이미지같은 소위 정적 리소스 개념을 벗어나는 지점부터 어려워지는 것 같다. </p>
<p>HTTP에서 <em>리소스란 뭐든 지 될 수 있다.</em></p>
<p>또한 REST를 CRUD로 치환하는 순간 이견은 좁혀지지 않는다. </p>
<p>조회&#x2F;등록&#x2F;수정&#x2F;삭제를 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE로 처리하는 게 REST라고 생각하면 더 이상의 이성적인 논쟁은 불가능해진다.</p>
<p>HTTP 메소드가 부족하다고 생각이 드는 건 모든 RPC 요청의 성격을 CRUD에 매핑하려는 시도에 원인이 있다고 본다.</p>
<p>어떤 기분인 지는 알 것 같다.</p>
<p>REST API는 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE를 쓰는 것 -&gt; 곧 조회&#x2F;등록&#x2F;수정&#x2F;삭제를 의미 -&gt; RPC 업무는 조회&#x2F;등록&#x2F;수정&#x2F;삭제 네 가지로 단순하게 떨어지지 않아!</p>
<p>각 HTTP 메소드가 정확히 어떤 의미인지는 각자 (제발 신뢰할 만한 출처에서) 찾아보기로 하고,</p>
<p>REST 논문에는 애초에 CRUD나 어떤 HTTP 메소드를 써야 한다는 언급이 없었다.</p>
<p>‘REST API는 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE를 쓰는 것이다’라는 공식은 웹 프레임웍의 잘못된 가이드에도 원인이 있기도 하다.</p>
<p><a target="_blank" rel="noopener" href="http://www.eq8.eu/blogs/37-post-create-and-put-update">Ruby on Rails의 예</a>를 보자.</p>
<ul>
<li>PUT을 썼더니 방화벽에서 막혔던 사례를 통해 이때 발생할 수 있는 문제를 다루고 레일스의 잘못된 가이드에 대해 언급한다</li>
<li>마지막 결론쯤에 Rails는 Rails일 뿐이라는 대목이 나온다</li>
<li>Best practice를 쫓아가면 좋긴하지만, 이해용이성을 조금 포기해야 하기도 한다</li>
</ul>
<p>PHP의 Laravel은 </p>
<ul>
<li>5.2 버전까지 <a target="_blank" rel="noopener" href="https://laravel.com/docs/5.2/controllers#restful-resource-controllers">RESTful Resource Controllers</a>라는 용어를 사용했으나,</li>
<li>5.3 버전부터는 <code>typical &quot;CRUD&quot; routes</code>를 제공한다는 설명과 함께 <a target="_blank" rel="noopener" href="https://laravel.com/docs/5.3/controllers#resource-controllers">Resource Controllers</a>라고 변경했다. 하지만 여전히 PUT은 UPDATE에 대응이 된다.</li>
</ul>
<h3 id="307-Temporary-같은-애들은-브라우저마다-상이하게-처리되기도-한다-제대로-지원하는-건-200과-500뿐이다"><a href="#307-Temporary-같은-애들은-브라우저마다-상이하게-처리되기도-한다-제대로-지원하는-건-200과-500뿐이다" class="headerlink" title="307 Temporary 같은 애들은 브라우저마다 상이하게 처리되기도 한다. 제대로 지원하는 건 200과 500뿐이다."></a>307 Temporary 같은 애들은 브라우저마다 상이하게 처리되기도 한다. 제대로 지원하는 건 200과 500뿐이다.</h3><p>좀 오버하는 감은 있긴 하다.</p>
<p>하지만 REST에서는 Uniform Interface가 중요한데도 경험적으로 (적어도 HTTP 쪽에서는) 인프라가 충분치 않다는 인식이 있는 것 같다. </p>
<p>위에 Ruby on Rails의 예에서 언급한 것처럼 보안을 이유로(?) PUT을 지원하지 않는 방화벽이랄지,</p>
<p>HTTP 응답 코드를 각기 다르게 해석하는 클라이언트 등 현실적인 제약은 다반사인 것 같다.</p>
<p>구현을 하는 입장에선 아무래도 이런 부분에선 부담이 되는 게 사실이다. (IE 대응을 위해 버려진 수많은 나날을 생각해보자)</p>
<h3 id="HTTP의-문법은-풍부하지-못해서-모든-어플리케이션의-요청과-응답을-표현할-수-없다"><a href="#HTTP의-문법은-풍부하지-못해서-모든-어플리케이션의-요청과-응답을-표현할-수-없다" class="headerlink" title="HTTP의 문법은 풍부하지 못해서 모든 어플리케이션의 요청과 응답을 표현할 수 없다"></a>HTTP의 문법은 풍부하지 못해서 모든 어플리케이션의 요청과 응답을 표현할 수 없다</h3><p>이것도 사실 각자의 상황에 맞는 Best Practice의 부재 탓이라고 본다.</p>
<p>HTTP가 끝없는 업계의 요구사항에 매번 응답코드를 추가해줄 수는 없다.</p>
<p>답답하겠지만 결국 개발자는 결정을 해야한다. 현실 세계의 문제는 원래 그렇다.</p>
<h3 id="RESTful-API는-디버깅-하기-힘들다"><a href="#RESTful-API는-디버깅-하기-힘들다" class="headerlink" title="RESTful API는 디버깅 하기 힘들다"></a>RESTful API는 디버깅 하기 힘들다</h3><p>이에 대한 반론 중에는 개발자도구나 HTTP client 툴을 사용하면 된다고들 하지만,</p>
<p>이 블로그 글쓴이의 의도는 요청&#x2F;응답 시 신경써야 하는 부분이 많다는 것이다.</p>
<p>난 맞는 지적이라고 생각한다.</p>
<p>SOAP이나 GraphQL처럼 응답 메시지 본문에서 모든 상황을 지켜보고 싶은 마음을 나도 십분 이해한다.</p>
<p>하지만 REST는 쉽게 개발하려고 만든 아키텍처 스타일이 아니다.</p>
<p>웹의 인프라를 충분히 활용해서 효율적으로 동작하고, 독립적으로 진화하고, 확장할 수 있게 설계하기하기 위함이다.</p>
<p>디버깅을 편하게 하기 위해 설계 원칙을 바꾸는 순간 본래의 목적에서 멀어진다.</p>
<h3 id="HTTP에-너무-종속되어-있다"><a href="#HTTP에-너무-종속되어-있다" class="headerlink" title="HTTP에 너무 종속되어 있다"></a>HTTP에 너무 종속되어 있다</h3><p>웹에서의 주요 프로토콜이 HTTP이긴 하고, 그 때문에 REST를 구현했다는 사람들이 HTTP를 많이 쓸 뿐이지 REST는 HTTP에 한정되지 않는다.</p>
<p><a target="_blank" rel="noopener" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_3_2">5.3.2 Connector View</a> 참고</p>
<h3 id="아무리-이론적으로는-맞는-말일-지라도-현실적으로는-대부분-HTTP-위에서-REST를-구현할-수-밖에-없잖아"><a href="#아무리-이론적으로는-맞는-말일-지라도-현실적으로는-대부분-HTTP-위에서-REST를-구현할-수-밖에-없잖아" class="headerlink" title="아무리 이론적으로는 맞는 말일 지라도, 현실적으로는 대부분 HTTP 위에서 REST를 구현할 수 밖에 없잖아"></a>아무리 이론적으로는 맞는 말일 지라도, 현실적으로는 대부분 HTTP 위에서 REST를 구현할 수 밖에 없잖아</h3><p>맞다. 웹개발자 입장에선 대부분의 API 설계를 HTTP 위에서 하게 된다.</p>
<p>하지만 그것이 REST가 HTTP에 종속됐다는 의미는 아니다.</p>
<h3 id="HTTP를-재발명-하자는-게-아니다-단지-어플리케이션-레벨의-메시지를-HTTP-안에-억지로-끼워넣지-말고-JSON-payload에-담자는-말이다"><a href="#HTTP를-재발명-하자는-게-아니다-단지-어플리케이션-레벨의-메시지를-HTTP-안에-억지로-끼워넣지-말고-JSON-payload에-담자는-말이다" class="headerlink" title="HTTP를 재발명 하자는 게 아니다. 단지 어플리케이션 레벨의 메시지를 HTTP 안에 억지로 끼워넣지 말고 JSON payload에 담자는 말이다."></a>HTTP를 재발명 하자는 게 아니다. 단지 어플리케이션 레벨의 메시지를 HTTP 안에 억지로 끼워넣지 말고 JSON payload에 담자는 말이다.</h3><p>그래도 된다고 생각한다. 다만 그렇게하면 REST라고 부르지 말자는 것이다. REST라고 부를 수 없다고 나쁜 설계는 아니다.</p>
<p>글쓴이가 제시하는 JSON-Pure API는 “json-ld&#x2F;hydra”와 같은 hypermedia를 사용하는 REST(중의적인 의미) 사람들을 따라하고 있을 뿐이라는 의견도 있다. (지원하는 클라이언트가 얼마 없지만…)</p>
<p>hypermedia를 구현하기 위한 수많은 API 표준이 존재하는데, 후속 블로그에서 더 다뤄보겠다.</p>
<h3 id="JavaScript를-비활성하면-REST를-쓸-수가-없다-HTML은-GET-x2F-POST밖에-지원하지-않는다"><a href="#JavaScript를-비활성하면-REST를-쓸-수가-없다-HTML은-GET-x2F-POST밖에-지원하지-않는다" class="headerlink" title="JavaScript를 비활성하면 REST를 쓸 수가 없다. HTML은 GET&#x2F;POST밖에 지원하지 않는다."></a>JavaScript를 비활성하면 REST를 쓸 수가 없다. HTML은 GET&#x2F;POST밖에 지원하지 않는다.</h3><p>계속되는 HTML의 PUT&#x2F;DELETE 지원 논쟁.</p>
<p>XHR을 쓰면 된다는 부류와 XHR을 못쓰는 환경이 있는데 어떡하냐는 부류가 자주 부딪힌다.</p>
<p>미안하지만 REST는 Architectural Styles일 뿐 당신들이 request 하나하나를 어떻게 구현하는지 관심이 없다.</p>
<p>내 개인적인 생각으로는 어느 시스템이든 각각의 제약 사항은 존재하기 마련이다.</p>
<p>부족하면 부족한대로 해결해내는 것이 개발자가 할 일이라고 본다.</p>
<p>그러다보면 REST의 제약사항을 어길 수밖에 없는 상황도 분명 올 수 있겠지.</p>
<p>다시 말하지만, 그럼 REST라고 안 부르면 된다!</p>
<p>가장 적당한 디자인을 설계하자.</p>
<h3 id="가서-SOAP으로-입-좀-행구고-오지-그래"><a href="#가서-SOAP으로-입-좀-행구고-오지-그래" class="headerlink" title="가서 SOAP으로 입 좀 행구고 오지 그래"></a>가서 SOAP으로 입 좀 행구고 오지 그래</h3><p>네가 하려는 건 SOAP과 다를 바 없다는 중의적 의미.</p>
<p>댓글에서 SOAP과의 비교를 하는 사람이 참 많다. 여기 <a target="_blank" rel="noopener" href="http://greatkim91.tistory.com/79">REST와 비교한 글</a>도 참고하자. </p>
<p>(이 블로그는 국내에서 보기 드물게 REST에 대해 정확한 표현을 하고 있음에도 이 글에서는 제대로 REST를 설명하고 있지 않는데, 그 이유는 <a target="_blank" rel="noopener" href="http://greatkim91.tistory.com/13">ROA에 관한 그 분의 다른 글</a>에서 볼 수 있다. 여기서 REST는 아키텍처 스타일, RESTful Web Service는 아키텍처로 구분하고 있는데, 이게 얼마나 신방성 있는지는 좀 더 찾아봐야겠다. ROA는 나중에 다시 다뤄보겠다.)</p>
<p>‘소위 REST’가 SOAP을 대체해 나간 것처럼 기술이 오래 살아남기 위해선 사람들이 얼마나 쉽게 받아들일 수 있는가도 무시할 수 없는 것 같다.</p>
<h3 id="결국-누군가-나서서-논쟁을-정리한다"><a href="#결국-누군가-나서서-논쟁을-정리한다" class="headerlink" title="결국 누군가 나서서 논쟁을 정리한다"></a>결국 누군가 나서서 논쟁을 정리한다</h3><p>(좋은 내용인데 이렇게 밖에 해석할 수 밖에 없어서 미안하다)</p>
<ul>
<li>REST는 API가 아니야. API를 디자인 하기 위한 패턴이야. 그것은 매우 엄격하게 또는보다 실용적인 방식으로 고수 될 수 있으며 현실 세계에서 구현하기 위한 모범 사례가 무엇인지에 대해 의견 차이가 있지.</li>
<li>XMLHttpRequest는 모든 CRUD문법을 지원하고 있어. 10년 정도를 넘지 않은 모든 메이저 브라우저는 REST를 완벽하게 지원해.</li>
<li>REST API는 도메인에 종속된 메시지 교환을 충실히 지원하는게 목적이 아니야. HTTP 레이어가 트랜잭션의 상태에 대한 정보를 갖고 있지. 즉, 일반적인 HTTP client와 프로토콜을 구현할 의무가 있는 서버에게 유용한 방식이야. 이 컴포넌트들이 도메인 특정의 어플리케이션이 도메인에 종속된 로직을 처리하도록 메시지 페이로드를 전달하고 있지. 이건 대부분의 메시지 교환 방식에서 사용하고 있어. 프로토콜에서 하나의 역할을 하는 시스템은 자신이 필요한 부분만 읽고 서브 시스템에게 넘겨주지. TCP&#x2F;IP 위에서의 HTTP 응답을 예로 들면 IP packet과 TCP 헤더는 HTTP client가 읽기도 전에 TCP client에서 읽히고 처리되지. 단순히 다음 프레임으로 넘어가서 메시지를 해석할 수 있는 어플리케이션 코드에게 메시지를 전달하면 되는데, 왜 굳이 HTTP 프로토콜을 확장해야 하는거지? 모든 REST 원칙은 URL이나 HTTP 동사와 같은 일반적인 개념을 제공하는 HTTP 프로토콜을 이용하고, 이를 페이로드 안에서 재발명하지 않을 것을 권고하고 있어. 그렇게 함으로써 페이로드의 내용을 더 가볍고 간단하게 만들 수 있고, 대부분의 HTTP client가 공짜로 제공해주는 캐싱 같은 이점도 누릴 수 있지.</li>
<li>네가 언급한 7가지 영역은 사실 모두 요청과 응답이라는 2개의 조각에 나뉘어 있어. 커스텀 JSON에 모두 묻어버릴 때와 같이 말이지. 다른 점이 있다면, 대부분의 개발자는 이미 이 형식에 익숙해서 HTTP 요청과 응답 안의 정확히 어디를 봐야할 지 안다는 사실이지. HTTP 인터렉션을 디버깅을 위한 (네 브라우저에도 있는) 훌륭한 툴을 모두 언급하지는 않을게.</li>
<li>내가 이미 지적했지만, REST는 API설계를 위한 패턴이지 HTTP로 제한된 건 아니야. RESTful한 디자인 관점은 네 API를 대부분의 전송 프로토콜 안에서 깨끗하고 일관되고 성능도 좋고 캐시하기도 좋게 도와주지. HTTP에서 적용하기 쉬운 이유는 REST의 많은 원칙들이 HTTP로부터 영향을 받았기 때문이야.</li>
<li>넌 프로토콜과 컨텐츠에 대해 혼란스러워하고 있어. 네가 말하고 있는 건, HTTP 프로토콜의 3가지 information 조각이야. 리소스 식별자, 명령어 동사, 응답 코드. 응답코드가 메시지 컨텐츠로 절대로 볼 수 없다고는 말할 순 없지만, 트랙잭션의 상태를 나타내는 표준 코드는 완전히 프로토콜의 일부야. 나머지 것들도 메시지 교환에서의 보편적인 개념이고 프로토콜 레이어 상에서 이를 명시하는 것은 아무런 해가 되지 않아.</li>
</ul>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>많은 사람들은 REST가 좋은 설계 패턴이라고 생각하면서 REST를 제대로 이해 못한 채 API&#x2F;서비스를 만들고 여기에 RESTful이라는 표현을 쓰고 있다.<br>그건 REST가 아니라고 말을 해줘도, 그럼 어떻게 구현하냐고 따지고 든다.</p>
<p><em>마치 REST라는 용어를 반드시 써야만 하는 사람들처럼.</em></p>
<p>2008년 논문의 저자 Roy도 사람들이 REST에 대해 오해하는 것에 대해 한탄하며 글을 썼는데, 이는 다음 포스트에서 다룰 예정이다.</p>
<p>이 논쟁에서 등장한 근거와 여러 링크가 궁금하다면 제일 하단 추천 링크도 확인해 볼 것!</p>
<h2 id="댓글-정리"><a href="#댓글-정리" class="headerlink" title="댓글 정리"></a>댓글 정리</h2><p>양이 너무 많아서 정말 대충 막 그냥 해석해서 써갈겼지만, 써 놓고 보니 또 아깝고 해서 쓸데 없지만 붙여 넣어본다.</p>
<p>각 댓글 앞에는 이 글에 대한 찬반 표시를 했다</p>
<ul>
<li>이 글에 찬성하는 편 &amp;#128077;</li>
<li>이 글에 반대하는 편 &amp;#128078;</li>
<li>쓸데없는 소리 &amp;#128169;</li>
</ul>
<hr>
<p>&amp;#128078; 너 정말 REST를 제대로 이해하는 거 맞어?<br>&amp;#128078; 그 문법이 좀 혼란스러운 건 맞어. 그런데 그건 HTTP의 문제 아니냐?<br>&amp;#128078; REST는 HTTP에 종속된 게 아니야</p>
<ul>
<li>&amp;#128169; 난 왜 이걸 (머릿속에서) 화난 목소리로 읽고 있는거야</li>
<li>&amp;#128077; 무슨 소리야. HTTP의 문법이 사용되고 있는데. 그리고 현실에선 99%는 HTTP위에서 쓴다고<ul>
<li>&amp;#128078; 로이 필딩의 논문 Section 5.2.1.2는 너랑 생각이 좀 다른 것 같은데? REST는 아무 representation이나 사용할 수 있어. 바이너리 프로토콜이라도 말이지.<ul>
<li>&amp;#128077; 원래 논문이 어쨌든 현실에선 아무 의미가 없어. 단지 몇 가지 아이디어와 이름만 가져왔을 뿐이라고.<ul>
<li>&amp;#128078; 아닌데? 최초 거기서 설명된 것이 바로 핵심이야. HTTP 동사와 상태 코드에 어플리케이션 관점의 의미를 부여하는 게 사실상의 REST의 의미가 되고 있지만, 내 생각엔 그건 REST의 핵심이 아니야. 하지만 오늘날의 이른바 REST를 원래 묘사된 것보다 더 관련있고 유용하고 정확하게 만들어주는 그런 구현이 없긴하지.</li>
<li>&amp;#128078; 어떤 면에서는 반대로 생각해. 어플리케이션 도메인의 의미를 HTTP 도메인으로 확장하려고 하면 좋은&#x2F;우수 사례는 존재하지 않아. 단지 다양한 의견, 느슨한 명세와 설명의 묶음이 될 뿐이지. 사실 그 중 어느것도 확실하게 실용적인 주장이라고 정당화하긴 어려워. 요즘 널리 퍼진 소위 RESTful 베스트 프랙티스는 대부분은 개발자들 기분 좋으라고 있는거지, 원래의 의미를 기초로 하거나 필요로 하지 않는 것들이야.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128078; 인터넷 이야기를 해보자고. 그 거대하게 연결된 웹 자체가 이미 REST가 잘 동작하는 훌륭한 예라고. 20만개의 사이트가 20년 후에도 잘 돌아갈 거야.</p>
<ul>
<li>&amp;#128077; 뭐가 잘 동작한다는 거야? 평이한 링크들은 관심도 없거니와 여기서 다루는 문제가 아니야. 여기선 REST가 어떻게 사용되고 있는가에 대해서 이야기 한다고. 특히 IPC같은 것들.</li>
<li>&amp;#128077; 20만개의 사이트가 잘 돌아가는 건 그동안 문서의 저장소로서 존재했기 때문이야.</li>
</ul>
<p>&amp;#128078; 오해를 한 것 같은데, REST는 전송 프로토콜과 언어에 대해서는 언급하고 있지 않아. 위키디피아를 봐 “RESTful systems typically, but not always, communicate over the Hypertext Transfer Protocol “<br>&amp;#128077; 당신이 아무리 철학적으로 올바른 말을 해도, HTTP위에서 REST를 구현하려는 시도는 어쩔 수 없는 현실이야. 쉽고 객관적으로 써보려고 노력했는데 잘 안된 것 같군. 곧 JSON-pure API에 관한 추가 포스팅을 올리도록 하지</p>
<ul>
<li><p>&amp;#128078; 신경질적으로 반응한 건 미안한데, 글 제목이 좀 자극적이긴 하잖아. 당신의 그 json-pure api는 어떻게 전송하는지 말해줄래?</p>
<ul>
<li>&amp;#128077; 우선 다음 포스트(링크)를 확인하면 많은 부분 답이 될 거야</li>
<li>&amp;#128077; REST에 관한 나의 묵상..이렇게 제목을 지어놓으면 누가 보기나 하겠어?</li>
<li>&amp;#128077; 난 HTTP를 재발명하자고 제안하는 게 아냐. http는 훌륭한 매커니즘이고, json은 GET이나 POST를 사용해 표준 application&#x2F;json contents-type으로 HTTP위에서 전송이 되지. 난 대부분의 어플리케이션 레벨의 메시지를 http안에 억지로 끼워넣지 말고 json안에 넣자는 거야. 그게 훨씬 api를 간편하고 신뢰할 수 있게 만들어 주니까.</li>
<li>&amp;#128077; 어쨌든 이미 많은 사람들이 이 문제를 지적했다고 확신해. 이게 뭐 대단한 것도 아니고. 난 웹개발자의 관점에서 전형적인 RESTful API 구현체가 왜 종종 안 좋은 방법인가에 대해 간략하게 정리하고 싶었을 뿐이야.</li>
<li>&amp;#128077; 추가: 내가 일반적인 http를 예로 들었지만, 이 방법은 쉽게 웹소켓이나 다른 전송 방식에서 구현할 수 있어. json에 요청과 응답에 필요한 거의 모든 것을 넣어놨기 때문이지.</li>
<li>&amp;#128078; 사실 너는 “json-ld&#x2F;hydra”와 같은 hypermedia를 사용하는 REST(중의적인 의미) 사람들을 따라하고 있을 뿐이야. 그 사람들이 더 잘하고, 표준도 만들고 있고, http를 해치지도 않지. 이미 존재하는 것을 이용하는 게 더 좋긴 하지만, 이 방식의 가장 큰 문제는 hypermedia의 개념이 아직 널리 퍼지지 않아서 지원하는 클라이언트가 엉망이라는 점이야. </li>
<li>&amp;#128077; 뭐하러 직렬화한 것을 전송하는데 contents-type까지 붙여야 하지?…(역주) 이렇게 시작하는 답글이 있으나 문장을 끊어쓰지 않아서 뭔 소린 지 잘 모르겠음. 어쨌든 다양한 클라이언트를 대응하고 클라이언트가 기대하는 대로 응답하기에는 좋은 생각인 것 같다는 말인 것 같음.</li>
</ul>
</li>
<li><p>&amp;#128077; 정말 재밌게 읽었어. api를 설계할 때 나눠야할 깊은 논의에 있어 좋은 출발점이 될 것 같아.</p>
<ul>
<li>&amp;#128077; 고마워 넌 다음 글도 좋아할 것 같아</li>
</ul>
</li>
<li><p>&amp;#128169; <em>에헴</em> graphql <em>에헴</em> (역주 graphql이란 게 있는데…란 )</p>
</li>
</ul>
<p>&amp;#128078; 디버깅하기 어렵고 DELETE&#x2F;PUT이 지원하지 않는다고? 지금 몇년도에 살고 있는거야?</p>
<ul>
<li><p>&amp;#128077; 2016에 html form에서 DELETE&#x2F;PUT이 지원하나보지? 지원 안하면 javascript를 disable시킨 환경에서 어떻게 rest를 사용할건데? - 이건 인터뷰 질문으로 쓰기 좋겠구만</p>
<ul>
<li>&amp;#128078; 누가 2016년에 request 보내는데 form을 쓰냐? 누가 2016년에 js를 끄고 브라우저를 쓰고 누가 js가 제공하는 기능을 모두 기대하겠냐고. js를 켜는 것은 2016년에는 필수라고.<ul>
<li>&amp;#128077; 많은 큰 기업에서 보안을 이유로 xhr을 끄고 form을 쓰도록 하고 있어. 이름을 댈 수는 없지만 많은 기업이 여전히 IE7을 쓰고 있고 심지어 일부는 xp에 ie6을 쓰고 있지.<ul>
<li>&amp;#128077; 그리고 ajax는 일반적인 브라우저의 네비게이션 히스토리를 따르고 있지 않아. 그렇다면 history api를 써야겠지? 그러다 이런 생각이 들거야. 왜 여전히 form이 html의 가장 주요한 스펙으로 남아있을까.</li>
<li>&amp;#128077; 나도 요즘엔 form이 덜 쓰인다고 생각해. 내가 하고싶은 말은, 당신이 어떤 길을 걸어갔던지 모든 문제는 항상 그렇게 간단하지만은 않다는 거야.</li>
</ul>
</li>
<li>&amp;#128169; 별 바보같은 댓글 다 보겠네 ㅋ 그럼 html5나 css도 호환성 문제가 있으니 갖다 버리라고 그래.</li>
<li>&amp;#128077; 많은 큰 기업들이 보안을 이유로 PUT과 PATCH를 막고 있어. 최근 일했던 곳에서 이 둘을 허가받기 위해 엄청 설명을 해야했어. 큰 기업 환경에선 완전한 RESTful은 아직 쉽지 않지.</li>
</ul>
</li>
</ul>
</li>
<li><p>&amp;#128078; 내가 오해를 하고 있나? 확인해보니 HTML에서 둘 다 잘 지원하는데?</p>
<ul>
<li>&amp;#128077; GET, POST, PUT and DELETE 이런 거는 다 HTTP 표준인데, HTML에서 지원하는 건 GET&#x2F;POST 밖에 없어. 최신 브라우저는 지원할지도 모르겠지만, 대부분의 개발환경은 2010~2013년 시대에 머물러 있어. <a target="_blank" rel="noopener" href="http://laraveldaily.com/theres-no-putpatchdelete-method-or-how-to-build-a-laravel-form-manually/">http://laraveldaily.com/theres-no-putpatchdelete-method-or-how-to-build-a-laravel-form-manually/</a> 이런 걸 봐.<ul>
<li>&amp;#128169; 1970년대에 살고 있으면 비주얼 베이직이나 어셈블러나 하시지. 지금 2017년이야 정신차려.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128169; 가서 비누(역주 : 그거 SOAP 아니냐는 중의적 의미)로 입 좀 행구고 오지 그래</p>
<ul>
<li>&amp;#128077; 웃긴 건 둘째치고, 이건 SOAP이랑 다른 거야. SOAP의 문제는 복잡성과 망할 스펙이지. 내가 해봐서 알아. 이건 너네의 HTTP 기반의 RESTful보다 훨씬 쉽다고.</li>
</ul>
<p>&amp;#128078; 마이클! 로이와 그의 논문에 대한 항목은 좀 축소하거나 삭제할 필요가 있어. 당신이 설명하는 것은 HTTP 위에서의 CRUD이지 로이가 설명했던 것과는 달라. 사실 그게 REST라고 불리고는 있지만, 로이의 논문과 관련있는 것은 단지 사람들이 완전히 다른 것을 가져오기 위해 납치한, 그가 사용한 REST란 이름 뿐이라고. REST에 대한 현대적 관행의 결점을 그의 탓으로 돌리는 건 공정하지 않아.</p>
<ul>
<li>&amp;#128077; 나도 당신의 의견에 동의하고, 당신이 쓴 그 내용을 서론에 추가해도 좋을 것 같아. 괜찮아? 내가 RESTful web services에 대해 논의했던 모든 웹개발자는 위에 쓴 그대로 REST를 설명하고 있었어. 맞아, 메소드들과 응답코드를 사용하긴 해도  기본적으로는 HTTP위에서의 CRUD일 뿐이지. 다음주에 더 설명해볼게.<ul>
<li>&amp;#128078; 고마워. hypermedia api를 한번 살펴봐 “RESTful Web API 웹 API를 위한 모범 전략 가이드”란 책이나 <a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/hypermedia-web">https://groups.google.com/forum/#!forum/hypermedia-web</a> 을 아직 모른다면. 거기선 사람들이 CRUD를 REST와 헷갈리지 않거든. 너도 아마 좋아할거야.</li>
</ul>
</li>
</ul>
<p>&amp;#128078; 난 네가 JSON을 사용하는 SOAP을 쓰자고 하는 것 같은데. 세세한 제약이 있는 RPC스타일 API가 어려운 건 다 이유가 있어. 많은 이가 지적했지만, 보통 오해하는 것처럼 REST가 CRUD는 아니야. HTTP 동사를 CRUD로 단순화하면 representation의 개념을 놓치게 돼. 이는 그 패턴이 잘 돌아가게끔 도메인 엔티티를 추상화하지. 나아가 각자가 정의한 의미들을 JSON payload에 담아보내는 것이  HTTP동사&#x2F;응답 패턴보다 쉽다고 하는게 이해가 안돼. 적어도  HTTP동사&#x2F;응답에 관해선 표준적인 사용법이 있잖아.</p>
<ul>
<li>&amp;#128078; 하나 더 이야기하자면, REST의 HATEOAS관점은 매우 중요해. 로이도 그렇게 이야기 했고. 그걸 지키지 않은 건 REST라고 할 수 없지. 이건 SOAP의 정적인 발견가능성을 넘어서, 제대로만 만든다면 API를 실시간으로 인터렉티브하게 만들어줄 수 있지.</li>
</ul>
<p>&amp;#128078; 이런 끔찍한 글을 쓰기 전에 REST나 공부해. 틀린 점을 말해줄게. #1. 코드의 의미는 API개발자들이 잘 이해하고 있어. #2. 동사들을 지원하기 위해 API 설계자들은 그걸 다 구현해야 하지(모든 웹 서비스가 다 그런 거잖아. 이상한 소릴 하는구만). 이건 API설계에 대한 이야기야. HTML이 몇몇 동사를 지원하지 않겠지만, API에 HTML을 사용해선 안돼. 그래서 JSON이나 XML을 써야하지. #3. 추가적인 동사는 필요없어. 리소스 기반 설계에 대해 공부 좀 해봐. 내가 아래에 몇가지 알려줄게. REST는 특히 캐싱에 대해 고려하거나 이로써 대역폭에 관해 효율적으로 동작해. #4. REST는 디버깅이 존* 쉬워. 브라우저나 Firebug, postman 등… 사실 REST가 가진 장점이라고 할 수 있지. 다른 웹서비스는 훨씬 더 어렵다고. #5. REST가 HTTP에 강력하게 묶일 필요는 없어. 다른 프로토콜을 섞어 쓸 수도 있고, 그게 안티 패턴도 아냐. 더 이상 나쁜 소리하기 싫으니까 조만간 내가 추천하는 걸 좀 찾아보길 바라. API-craft google group, Books: REST in practice, RESTful Web APIs, RESTful Webservices</p>
<ul>
<li>&amp;#128077; 트위터나 그런 10~20개 정도의 리소스를 매핑할 수 있는 아주 제한된 기능을 가진 사이트에서는 아주 훌륭한 이야기들이야. 그런데 이런 사이트들은 실제 비지니스 시스템에 비해 아주 원시적인 기능들만 제공할 뿐이야. 내가 10년이상 REST를 경험해봤는데, REST를 제대로 할 수 있는 시스템은 본적이 없어. 다른 사람들도 내가 하고있는 의료 분야처럼 복잡한 어플리케이션을 다루고 있어. 200개의 테이블이 있고, 150개의 트랜잭션을 위한 테이블이야 말할 것도 없고…REST를 사랑하시는 여러분이 내가 하고 있는 시스템에서 ‘적절한 REST’ 인터페이스를 정의해나가는 게 얼마나 걸릴지 궁금하군. 당연히 JSON RPC API가 유지보수하기에 훨씬 쉽고, 네가 REST로부터 멀어질 수록 더 단순하고 유지보수 비용이 줄게 되지. REST는 작은 서비스에서 쓰기 좋은 거라고.<ul>
<li>&amp;#128077; 브라우저에서 돌아가게 만든 ERP중에 REST로 구현할 놈은 하나도 없을 거라 생각해. 불행히도 많은 웹 개발자들은 ERP가 뭔지도 잘 몰라. 맨날 리소스, 확장성같은 거만 생가하지. 고객들은 빠른 응답과 브라우저에서 데스크탑 프로그램의 룩앤필을 갖는 것 등을 원하는데 말야. RESTful은 이걸 절대 이룰 수 없어. 요구사항이 적을 때나 가능한 일이라고.<ul>
<li>&amp;#128077; ERP에 대한 설명이 웃기네. 완전 맞는 말이야. 이해관계자들은 REST가 아닌 비지니스와 회계를 신경쓰지. 빠른 개발과 응답을 원하고. 아무도 백엔드가 어떻게 생겼는지 신경 안 써. 어마어마한 요구사항에는 SOAP이 더 낫지. 난 SOAP이 싫지만 의료업계의 회계같은 곳에선 더 간단하다고 볼 수 있지.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128077; 내가 본 대부분의 json api는 심지어 REST가 아냐. twitter의 ‘REST’ api를 봐. 물론 몇 개는 REST라고 할 수 있지만, 저건 RPC에 가깝지.<br>&amp;#128078; 결국 넌 REST의 목적을 이해하지 못하기 때문에 REST가 나쁘다고 말하는 거구나. </p>
<ul>
<li><p>&amp;#128077; 아니, 난 REST를 시도때도 없이 사용하는 게 안 좋다는 거야. (곧 릴리즈될) Facebook Relay and Netflix Falcor도 - 전통적인 RESTful API를 벗어나는 것에 대한 - 같은 주제를 다루고 있지.</p>
</li>
<li><p>&amp;#128078; xhr 클라이언트는 request를 위한 모든 환경을 제공하고 있어.</p>
<ul>
<li>&amp;#128077; 맞아. 그러나 그건 XHR뿐이지, 다른 영역에선 여전히 GET&#x2F;POST만 제공하거든. 그리고 응답코드에 대해 지원하는 수준도 천차만별이야. 오래된 브라우저는 더 심하고. 게다가 네 client가 patch 메소드를 보낼 수 있다고 쳐도 서버가 그걸 구현했다는 의미는 아냐.</li>
</ul>
</li>
<li><p>&amp;#128078; 네가 이런 혼동에서 빠져나오기를 바란다</p>
<ul>
<li>&amp;#128077; 첫째, 난 혼란스럽지 않아. 둘째, 인신공격이 널 더 똑똑하게 만들어주지 않아.<ul>
<li>&amp;#128078; 인신공격이라고? 넌 혼동하는 게 맞아. 그건 팩트라고. 다른 코멘트도 모두 네 논리에 대한 결함을 이기 하고 있고. 넌 네가 이해하지 못하거나 구현할 수 없는 것에 대해 배척하는 것 뿐야. </li>
<li>&amp;#128169; (역주) 이후 개싸움이라 생략…</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128169; 2 Years later … GraphQL is rising. And GraphQL only use 200 and 500.<br>&amp;#128077; API 제공자가 아닌 소비자로서의 나의 문제는, 어떻게 파라미터를 전달할 지, 서비스를 어떻게 노출할 지, 리턴 데이터가 어떻게 되어야 할지 일관된 방법이 없다는 것이다</p>
<ul>
<li>&amp;#128077; 기본적으로 HTML을 통한 REST는 form에서 PUT, POST 등을 지원하지 않기 때문에 완전하지 않다. 왜 RESTful하기 위해 굳이 form이 아닌 xhr을 써야하나? 삭제는 어떻게 해야하는거야? HTTP+HTML만으로는 실무에서 제대로 구현하는 게 불가능하지.</li>
</ul>
<p>&amp;#128078; 내 생각에 REST의 유일한 문제는 REST 자체가 아니라 그걸 쓰는 사람들의 문제야. 왜냐면 REST는 종종 HTTP와 혼동하거나 HTTP없이는 구현할 수 없다고 생각하거든. 너도 똑같은 실수를 하는 것 같다고 생각하는 이유는,  넌 HTTP의 상태코드나 동사에 대해 불만이 있다고 말을 하지만 그건 REST랑 상관이 없는 얘기거든. 그건 HTTP에 정의된 거라고. 물론 네가 REST를 HTTP를 통해 구현할 수 있기도 하고, REST를 구현한다는 서비스들이 99%는 http를 쓰고 그 속성을 상속받게 되긴 하지.</p>
<p>&amp;#128078; 네가 지적한 건 뭐 하나 제대로 된 게 없어</p>
<ul>
<li>1 . REST는 API가 아니야. API를 디자인 하기 위한 패턴이야. 그것은 매우 엄격하게 또는보다 실용적인 방식으로 고수 될 수 있으며 현실 세계에서 구현하기 위한 모범 사례가 무엇인지에 대해 의견 차이가 있지. </li>
<li>2 . XMLHttpRequest는 모든 CRUD문법을 지원하고 있어. 10년 정도를 넘지 않은 모든 메이저 브라우저는 REST를 완벽하게 지원해.</li>
<li>3 . REST API는 도메인에 종속된 메시지 교환을 충실히 지원하는게 목적이 아니야. HTTP 레이어가 트랜잭션의 상태에 대한 정보를 갖고 있지. 즉, 일반적인 HTTP client와 프로토콜을 구현할 의무가 있는 서버에게 유용한 방식이야. 이 컴포넌트들이 도메인 특정의 어플리케이션이 도메인에 종속된 로직을 처리하도록 메시지 페이로드를 전달하고 있지. 이건 대부분의 메시지 교환 방식에서 사용하고 있어. 프로토콜에서 하나의 역할을 하는 시스템은 자신이 필요한 부분만 읽고 서브 시스템에게 넘겨주지. TCP&#x2F;IP 위에서의 HTTP 응답을 예로 들면 IP packet과 TCP 헤더는 HTTP client가 읽기도 전에 TCP client에서 읽히고 처리되지. 단순히 다음 프레임으로 넘어가서 메시지를 해석할 수 있는 어플리케이션 코드에게 메시지를 전달하면 되는데, 왜 굳이 HTTP 프로토콜을 확장해야 하는거지? 모든 REST 원칙은 URL이나 HTTP 동사와 같은 일반적인 개념을 제공하는 HTTP 프로토콜을 이용하고, 이를 페이로드 안에서 재발명하지 않을 것을 권고하고 있어. 그렇게 함으로써 페이로드의 내용을 더 가볍고 간단하게 만들 수 있고, 대부분의 HTTP client가 공짜로 제공해주는 캐싱 같은 이점도 누릴 수 있지.</li>
<li>네가 언급한 7가지 영역은 사실 모두 요청과 응답이라는 2개의 조각에 나뉘어 있어. 커스텀 JSON에 모두 묻어버릴 때와 같이 말이지. 다른 점이 있다면, 대부분의 개발자는 이미 이 형식에 익숙해서 HTTP 요청과 응답 안의 정확히 어디를 봐야할 지 안다는 사실이지. HTTP 인터렉션을 디버깅을 위한 (네 브라우저에도 있는) 훌륭한 툴을 모두 언급하지는 않을게.</li>
<li>내가 이미 지적했지만, REST는 API설계를 위한 패턴이지 HTTP로 제한된 건 아니야. RESTful한 디자인 관점은 네 API를 대부분의 전송 프로토콜 안에서 깨끗하고 일관되고 성능도 좋고 캐시하기도 좋게 도와주지. HTTP에서 적용하기 쉬운 이유는 REST의 많은 원칙들이 HTTP로부터 영향을 받았기 때문이야.</li>
<li>넌 프로토콜과 컨텐츠에 대해 혼란스러워하고 있어. 네가 말하고 있는 건, HTTP 프로토콜의 3가지 information 조각이야. 리소스 식별자, 명령어 동사, 응답 코드. 응답코드가 메시지 컨텐츠로 절대로 볼 수 없다고는 말할 순 없지만, 트랙잭션의 상태를 나타내는 표준 코드는 완전히 프로토콜의 일부야. 나머지 것들도 메시지 교환에서의 보편적인 개념이고 프로토콜 레이어 상에서 이를 명시하는 것은 아무런 해가 되지 않아.</li>
<li>&amp;#128077; 여기에 블로그 글쓴이가 논점에 벗어난 댓글을 담<ul>
<li>&amp;#128078; 여기에 다른 이가 항의함<ul>
<li>네가 말하는 건 모두 DSL interface를 만들기 위해 REST의 원칙들을 왜곡하려는 것 같은 일이야. 난 개인 감정으로 네 주장에 대해 지적하는 게 아냐. 넌 너무 방어적이라고. 네가 지적한 기술적 문제는 REST에 대한 납득할 만한 비평이 아냐. 모두가 지적하는 부분에 대해 그저 동의하는 척 끝내버리고 있어. 넌 기술적인 원칙들과 네 안 좋은 경험들을 분리하는 데 문제가 있는 것 같아. REST가 의도하지 않은 방향으로 구현된 걸로 REST를 까지말고, 구체적으로 네가 생각하는 이상적인 기술적인 세부사항을 그려보지 그래? 네 블로그 글은 REST의 결함에 대한 이해는 되지 않고, 왜 그것이 종종 잘못 구현됨으로써 만능 해결책이 되지 않는지에 대한 내용 뿐이야.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;#128169; facebook이 GraphQL 내놓았어 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html">링크</a></p>
<ul>
<li>&amp;#128169; 그럼 이것도 읽어보지 그래? <a target="_blank" rel="noopener" href="https://www.pandastrike.com/posts/20151015-rest-vs-relay">링크</a><ul>
<li>역주 : facebook의 글도 REST를 제대로 이해하고 쓴 건 아닌 것 같고, 이를 비판하는 글도 GraphQL을 제대로 이해하는 것 같지는 않음</li>
</ul>
</li>
</ul>
<h2 id="댓글에서-언급된-추천-링크"><a href="#댓글에서-언급된-추천-링크" class="headerlink" title="댓글에서 언급된 추천 링크"></a>댓글에서 언급된 추천 링크</h2><p><em>로이 필딩이 이야기하는 HATEOAS에 관한 이야기</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven</a></li>
</ul>
<p>API Conf Panel: The Future of Media API</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/media-API">https://www.infoq.com/presentations/media-API</a></li>
</ul>
<p><em>GOTO 2014 • REST: I don’t Think it Means What You Think it Does • Stefan Tilkov</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=pspy1H6A3FM">https://www.youtube.com/watch?v=pspy1H6A3FM</a></li>
</ul>
<p>JSON-RPC</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.jsonrpc.org/specification">http://www.jsonrpc.org/specification</a></li>
</ul>
<p>Facebook의 GraphQL</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://graphql.org/learn/">http://graphql.org/learn/</a></li>
</ul>
<p>Netflix의 Falcor</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://netflix.github.io/falcor/">http://netflix.github.io/falcor/</a></li>
</ul>
<p>RESTful Web API 웹 API를 위한 모범 전략 가이드</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788966261635">http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788966261635</a></li>
</ul>
<p>Hypermedia Web discussion group</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/hypermedia-web">https://groups.google.com/forum/#!forum/hypermedia-web</a></li>
<li>CRUD와 REST를 구별할 줄 아는 사람들</li>
</ul>
<p>API Craft google group</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://groups.google.com/forum/?hl=ko#!forum/api-craft">https://groups.google.com/forum/?hl=ko#!forum/api-craft</a></li>
</ul>
<p>Hypermedia Client Tutorial</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/apiacademy/2016-07-hyperclient">https://github.com/apiacademy/2016-07-hyperclient</a></li>
</ul>
<p>From Zero to Hyper in 30 Minutes: Live Coding a Hypermedia Client</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.infoq.com/presentations/http-client-javascript">https://www.infoq.com/presentations/http-client-javascript</a></li>
</ul>
<p>CODE COMPLETE 2</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788956742564">http://www.kyobobook.co.kr/product/detailViewKor.laf?barcode=9788956742564</a></li>
</ul>
<p><em>Your API isn’t RESTful — And That’s Good</em></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@trevorhreed/you-re-api-isn-t-restful-and-that-s-good-b2662079cf0e">https://medium.com/@trevorhreed/you-re-api-isn-t-restful-and-that-s-good-b2662079cf0e</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/24/rest-the-dissertation-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/24/rest-the-dissertation-summary/" class="post-title-link" itemprop="url">REST - 논문(요약) 훑어보기</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-24 12:06:17" itemprop="dateCreated datePublished" datetime="2017-05-24T12:06:17+09:00">2017-05-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/24/rest-the-dissertation-summary/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/24/rest-the-dissertation-summary/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="논문"><a href="#논문" class="headerlink" title="논문"></a>논문</h2><p>REST의 사전적인 의미부터 알아보자.</p>
<p>‘바쁜 개발자들을 위한 REST 논문 요약’을 요약 + WhatIsRest.com + 지난 며칠간 블로그와 댓글을 뒤져가며 얻은 지식 + 내 생각을 적어보려고 한다.</p>
<h2 id="REST-제약-조건"><a href="#REST-제약-조건" class="headerlink" title="REST 제약 조건"></a>REST 제약 조건</h2><p>논문에서는 아무것도 없는 웹 스타일에서 시작해, 제약 조건을 하나씩 추가해 나가며 REST 스타일을 유도해 나가는 과정을 통해 REST를 설명한다.</p>
<ol>
<li>Starting with the Null Style</li>
<li>Client-Server</li>
<li>Stateless</li>
<li>Cache</li>
<li>Uniform Interface</li>
<li>Layered System</li>
<li>Code-On-Demand</li>
</ol>
<p>각 제약 조건을 취하면서 발생하는 trade-off도 언급하고 있으나 여기서는 넘어가기로 한다.</p>
<h3 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client-Server"></a>Client-Server</h3><p>보통 생각하는 서버-클라이언트를 의미.</p>
<p>여기서 의문이 들었던 게, Client-Server라는 게 과연 제약조건이라고 할 수 있는 건가? 그러니까, 제약 조건을 어기는 게 과연 가능한가?</p>
<p>이 제약조건은 클라이언트와 서버의 역할을 명확하게 구분한다 정도로 생각하면 될 것 같다.</p>
<p>서로의 관심사를 분리하여 각각의 로직의 독립적인 진화를 지원해야 한다(중요).</p>
<h3 id="Stateless"><a href="#Stateless" class="headerlink" title="Stateless"></a>Stateless</h3><p>모든 요청은 필요한 모든 정보를 담고 있어야한다.</p>
<p>요청 하나만 봐도 바로 뭔지 알 수 있으므로 가시성이 확보된다.</p>
<p>API 문외한 입장에서 가장 이해가 안 됐던 부분 중 하나였다. 인증을 위해 쿠키를 심고 세션에서 필요한 정보를 가져오는 경우, 이는 stateless인가 아닌가?</p>
<ul>
<li>정답 : Session 정보 활용한다면 stateless가 아니다</li>
</ul>
<p>REST에서는 각각의 요청에 서버가 필요한 정보가 모두 담겨야 한다.</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>모든 서버 응답은 캐시 가능한 지 그렇지 않은 지 알 수 있어야 한다.</p>
<p>캐시를 고려한 설계가 필요하다.</p>
<h3 id="Uniform-Interface"><a href="#Uniform-Interface" class="headerlink" title="Uniform Interface"></a>Uniform Interface</h3><p>구성요소(클라이언트, 서버 등) 사이의 인터페이스는 균일(uniform)해야한다.</p>
<ul>
<li>이것만으로는 무슨 말인지 모르겠다</li>
</ul>
<p>WhatIsREST.com의 내용을 구글 번역으로 돌려보면 </p>
<ul>
<li><code>소비자는 많은 소비자와 서비스에서 표준화 된 방법, 미디어 유형 및 공통 리소스 식별자 구문을 통해 서비스 기능에 액세스합니다</code>라고 나오는데,<br>미디어 유형이나 리소스 식별자 등을 의미하는 문법이 구성요소나 호환 시스템 간 동일해야 한다는 의미</li>
</ul>
<p>균일한 인터페이스가 필요한 이유는</p>
<ul>
<li>서버 입장에선 어떤 클라이언트든 상관없이(내가 보내주는 것을 이해할 수 있을까 걱정없이) 표준에 의한 응답을 해줄 수 있고</li>
<li>클라이언트 입장에선 hypertext를 통해 다음 상태로의 이동을 해야하는데, 표준화된 방식을 통해 해당 서버의 특성을 알 필요가 없어진다</li>
<li>서로의 특성을 알지 못해도 커뮤니케이션이 가능할 수 있어야, 각각 독립적으로 진화할 수 있는 유연한 시스템이 만들어진다</li>
</ul>
<p>REST는 네가지 Interface 제약조건으로 정의된다</p>
<p><a target="_blank" rel="noopener" href="http://exyus.com/articles/rest-the-short-version/">네가지 Interface 제약조건</a>에서 언급된 내용을 구글 번역으로 좀 더 상세히 살펴보자.</p>
<ul>
<li>이 자원의 추상적 정의는 웹 아키텍처의 핵심 기능을 가능하게 합니다</li>
<li>유형이나 구현에 따라 인위적으로 구별하지 않고 많은 정보 소스를 포괄함으로써 보편성을 제공합니다 </li>
<li>표현에 대한 참조의 늦은 바인딩을 허용하여 요청의 특성에 따라 내용 협상을 수행 할 수 있습니다 </li>
<li>저자는 개념의 단수 표현보다는 개념을 참조 할 수 있으므로 표현이 바뀔 때마다 기존의 모든 링크를 변경할 필요가 없습니다</li>
</ul>
<h4 id="1-identification-of-resources"><a href="#1-identification-of-resources" class="headerlink" title="1. identification of resources"></a>1. identification of resources</h4><p>리소스를 식별하는 방법이 동일해야 한다. 우리는 보통 URI를 쓰기 때문에 어쩐지 당연한 말처럼 느껴진다.</p>
<h4 id="2-manipulation-of-resources-through-representation"><a href="#2-manipulation-of-resources-through-representation" class="headerlink" title="2. manipulation of resources through representation"></a>2. manipulation of resources through representation</h4><p>representation의 개념은 <a target="_blank" rel="noopener" href="https://blog.npcode.com/2017/04/03/rest%EC%9D%98-representation%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/">이응준님 블로그</a>에서 다루고 있다.</p>
<p>리소스의 표현계층(representation)을 리소스의 식별자(URL)로부터 분리한 것은 REST에서 아주 주요한 관점이다.</p>
<p>RESTful 응용 프로그램은 동일한 URI에서 동일한 자원의 표현을 둘 이상 지원할 수 있다.</p>
<h4 id="3-self-descriptive-messages"><a href="#3-self-descriptive-messages" class="headerlink" title="3. self-descriptive messages"></a>3. self-descriptive messages</h4><p>요청이나 응답 메시지에는 이를 이해하기 위한 모든 정보가 포함되어야 한다.</p>
<h4 id="4-hypermedia-as-the-engine-of-application-state"><a href="#4-hypermedia-as-the-engine-of-application-state" class="headerlink" title="4. hypermedia as the engine of application state"></a>4. hypermedia as the engine of application state</h4><p>줄여서 HATEOAS라고도 하지만 REST를 사랑하는 이들은 종종 이렇게 줄여부르는 걸 싫어하기도 한다(똑똑하고 재수없게 보이려면 ‘HATEOAS라고 줄여 부르는 건 바보같다’라고 말하면 된다).</p>
<p>훗날 블로그에서 Roy는 이 부분을 가장 강조하는데, 어쩌면 사람들이 가장 안 지키고 있기 때문일 지도 모르다는 생각을 했다.  </p>
<p>그리고 이를 언급할 때 주로 hypertext라는 표현을 사용한다.</p>
<p>논문에서 hypermedia라고 한 것은 단지 text가 아닌 매체를 고려했기 때문이고,</p>
<p>일반적인 API에서는 거의 hypertext라고 표현하면 된다.</p>
<p>음? 우리가 HTML 페이지에서 맨날 보는 그 hypertext라는 용어가 맞나?</p>
<p>맞다. 제시된 hypertext 위에서 application 상태를 변경하는 주체가 client가 되어야 한다는 게 핵심이다.</p>
<p>조대협님의 블로그에는 <code>HTTP Response에 다음 Action이나 관계되는 리소스에 대한 HTTP Link를 함께 리턴하는 것</code>이라고 언급이 되어 있다.</p>
<ul>
<li>뭔가…이상한데…틀렸다고 하기는 뭣 하지만 온전히 이해가 되는 문장은 또 아니다. 다른 사람의 의견을 더 들어보자</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://community.oracle.com/blogs/mkarg/2010/02/14/what-hateoas-actually-means">What HATEOAS actually means</a></p>
<ul>
<li>다들 혼란스러워하는 것 같은데 직접 로이 필딩에게 물어보지 그래?</li>
<li>로이의 문장은 명확하고, 모호하지도 않으니 그냥 읽어보길 바란다</li>
<li>로이가 HTTP 표준의 기여자라는 것을 잘 생각해보자</li>
<li>이 논문의 주제는 WWW가 잘 동작하고 확장성도 좋고, REST가 WWW 아키텍쳐 위에서 동작한다면, 이 역시 잘 동작하고 확장성이 좋다는 것이다</li>
<li>4가지의 제약 조건은 결국 URI를 사용해서 MIME-typed 문서를 GET&#x2F;PUT 등으로 전송하는 것 + HATEOAS</li>
<li>WWW :&#x3D; URI + HTTP + MIME + Hypermedia</li>
<li>Hypermedia라는 건 hypertext를 확장한 개념</li>
<li>좀 더 정확하게 쓰자면, HATEOAS :&#x3D; hypermedia documents as the state of state</li>
<li>로이의 배경을 생각하면 그는, 하이퍼링크가 없는 HTML 도큐먼트를 상상조차 못할 인물이다</li>
<li>그가 언급한 Hypermedia란 문서 자체를 의미한다</li>
<li>로이는 HTTP통신에 Link header를 넣어도 여전히 RESTful 할 수 있지만, 합당한 이유가 있어야 한다고 했다<ul>
<li>역주) 헤더에 넣으면 이를 처리할 수 없는 클라이언트도 있을 수 있기 때문에..라고 했는데 당시에는 LINK가 정식 표준이 아닌 때였기 때문인 것 같음</li>
</ul>
</li>
<li>HATEOAS를 정확히 구현한 것은 문서안에 있는 링크다</li>
<li>HATEOAS라는 다음 상태 변경을 위한 링크(form 링크 등)를 제공해야 한다는 것</li>
</ul>
<p>이 문서도 좀 제멋대로 해석한 부분이 있는데, Roy는 단지 HTTP만을 염두에 둔 게 아니다. HTTP이거나 HTML 문서이거나 그런 게 중요한 게 아니다.<br>HATEOAS라는 걸 응답에 다음 액션에 관한 링크를 전달하는 것 정도로 생각하면 안 된다.</p>
<ul>
<li>응답에 링크를 주렁주렁 달고 다니면 HATEOAS가 되는가? NO!</li>
<li>서버는 Hypermedia를 통해 다음 액션에 대한 선택지를 클라이언트에게 줘야한다</li>
<li>클라이언트는 서버의 독자적인 진화에 영향을 받아선 안 되며, 서버 상의 구현에 의존하면 안 된다</li>
</ul>
<p>결국 HATETOAS의 목적은 (서버-클라이언트 간 의존성을 분리해야만 가능한) 독자적인 진화와 확장을 보조하는 것이며, hypermedia는 그 목적을 이루는 데 기여해야 한다   </p>
<h3 id="Layered-System"><a href="#Layered-System" class="headerlink" title="Layered System"></a>Layered System</h3><p>클라이언트든 서버든 미들웨어 구성요소를 추가할 수 있는 구조.</p>
<p>하지만 Client-Server 사이에선 그 구성요소가 추가되는지, 다른 서비스와 추가로 통신하는 지 여부는 관심없다.</p>
<p>서버와 클라이언트 간 상호 작용을 일관성있게 유지해야 한다.</p>
<h3 id="Code-On-Demand-Optional"><a href="#Code-On-Demand-Optional" class="headerlink" title="Code-On-Demand (Optional)"></a>Code-On-Demand (Optional)</h3><p>서버가 네트워크를 통해 클라이언트에 프로그램을 전달하면 그 프로그램이 클라이언트에서 실행될 수 있어야한다. (Java applet이나 Javascript 같은 것을 말함).</p>
<p>다만 이 제약조건은 필수는 아니다.</p>
<h2 id="thanks-to"><a href="#thanks-to" class="headerlink" title="thanks to"></a>thanks to</h2><p><a target="_blank" rel="noopener" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">로이 필딩의 논문</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.npcode.com/">이응준님의 블로그</a>에서 많은 영감을 얻음</p>
<p><a target="_blank" rel="noopener" href="http://whatisrest.com/">WhatIsREST.com</a></p>
<p><a target="_blank" rel="noopener" href="http://exyus.com/articles/rest-the-short-version/">네가지 제약조건에 대한 짧은 설명</a> </p>
<p><a target="_blank" rel="noopener" href="https://community.oracle.com/blogs/mkarg/2010/02/14/what-hateoas-actually-means">HATEOAS가 진짜로 의미하는 것</a> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/23/rest-http-method-in-html-form/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/23/rest-http-method-in-html-form/" class="post-title-link" itemprop="url">REST - HTML Form에서 GET/POST만 지원하는 이유</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-23 23:12:12" itemprop="dateCreated datePublished" datetime="2017-05-23T23:12:12+09:00">2017-05-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/23/rest-http-method-in-html-form/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/23/rest-http-method-in-html-form/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="HTML-Form에서-GET-x2F-POST만-지원하는-이유"><a href="#HTML-Form에서-GET-x2F-POST만-지원하는-이유" class="headerlink" title="HTML Form에서 GET&#x2F;POST만 지원하는 이유"></a>HTML Form에서 GET&#x2F;POST만 지원하는 이유</h2><p>쉬어가는 마음으로 다음 장을 위한 사전 지식을 하나 쌓아보자.</p>
<p><a target="_blank" rel="noopener" href="http://jxck.hatenablog.com/entry/why-form-dosent-support-put-delete">왜 PUT과 DELETE를 지원하지 않는가</a>에 대한 정리</p>
<ul>
<li>일본어다. 구글 번역기를 돌려보자</li>
</ul>
<p>PUT&#x2F;DELETE를 Form에 넣으려는 시도는 위 글에서 가장 자세히 나오긴 했다.</p>
<p>(구글 번역이 훌륭하긴 해도) 일본어라 원본을 알아볼 수가 없으므로,<br>대신 <a target="_blank" rel="noopener" href="https://softwareengineering.stackexchange.com/questions/114156/why-are-there-are-no-put-and-delete-methods-on-html-forms">stackexchange에 올라온 글</a>로 짧게 정리해봤다.</p>
<ul>
<li>초기 HTML5 draft에는 포함되어 있었고 Firefox의 베타 버전에서는 잠시 구현하기도 했었다.</li>
<li>W3C는 이 문제를 <a target="_blank" rel="noopener" href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=10671">bug report 10671</a>에서 논의를 했는데,</li>
<li>Mike Amundsen이란 사람이 언급하길<ul>
<li>리소스를 수정하기 위해 PUT과 DELETE를 실행하는 건 모던 브라우저의 XmlHttpRequest 객체를 사용하면 간단한데, 스크립트를 사용하지 않는 상황에선 쉽지 않다.</li>
<li>이 패턴은 많은 일반적인 웹 프레임웍&#x2F;라이브러리에서 기본으로 구현하고 있다.</li>
<li>(그리고 이를 우회하는 방식에 대한 문제를 언급함)</li>
</ul>
</li>
<li>Tom Wardrop란 사람도 흥미로운 관점을 제시함<ul>
<li>HTML은 HTTP와 떼려야 뗄 수 없는 관계다. HTML은 인간을 위한 HTTP 인터페이스다. 따라서 왜 HTTP에서 필요한 메소드를 모두 제공하지 않는 것인가에 대해 자동으로 의문을 가질 수 밖에 없다. 기계는 PUT과 DELETE를 할 수 있으면서 인간은 왜 안 되는가?</li>
<li>HTML이 시맨틱한 마크 업을 보장하는 데 많은 시간을 할애하면서, 시맨틱한 HTTP 요청을 보장하기 위한 노력을 하지 않았다는 것은 모순이다.</li>
</ul>
</li>
<li>결국 이 버그는 (HTML editor인) Ian Hickson에 의해 고치지 않는 것으로 결정났다.<ul>
<li>“PUT을 form 메소드로 사용한다는 것은 말도 안 된다. 네가 form payload를 통해 PUT을 해야할 일은 없을 것이다. DELETE도 payload가 없어야만 말이 된다. 그러니 역시 form에서 제공할 이유가 없다.”</li>
</ul>
</li>
<li>하지만 포기하지 않고 추가 드래프트가 올라와 있다<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/TR/2015/NOTE-form-http-extensions-20150929/#http-put-form">https://www.w3.org/TR/2015/NOTE-form-http-extensions-20150929/#http-put-form</a></li>
</ul>
</li>
</ul>
<p>일본어로 정리된 글에서도 왜 PUT과 DELETE가 Form에서 적합하지 않은지는 생각하진 않은 것 같다.</p>
<p>추가된 드래프트도 결국 애초의 HTML Form이 가진 기능&#x2F;목적을 우회하여 Form을 활용한 PUT&#x2F;DELETE를 실행할 수 있도록 Form의 기능 확장(extension)을 요구하고 있다.<br>여기에서 DELETE는 크게 이질감이 없지만, PUT의 경우 payload를 통해 헤더를 구성하는 방식을 제안하고 있다. 그 방식은 꽤나 어색해서 과연 HTML 에디터나 커뮤니티 차원에서 받아들일 수 있을지는 미지수이다.</p>
<p>이슈를 닫아버린 Ian Hickson 입장에선 Form에서 PUT&#x2F;DELETE를 지원하는 게 너무 당연하게 말도 안 되는 일이라고 생각했을 것 같다. 이유는,</p>
<ul>
<li>Form은 서버에 정보를 제출하기 위해 존재한다</li>
<li>GET과 POST는 form에 존재하는 대화형 컨트롤에 입력된 값을 보낸다</li>
<li>POST와 PUT의 가장 큰 차이<ul>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">RFC2616</a>에서는 ‘요청 URI의 다른 의미’라는 표현을 썼고 </li>
<li><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7231#section-4.3.4">RFC 7231</a>에서는 ‘동봉된 representation에 대한 다른 의도’라는 표현을 썼다 </li>
<li>POST에서의 요청 대상 리소스는 동봉된 representation을 ‘처리하는’ 주체이고</li>
<li>PUT에서는 동봉된 representation은 대상 리소스의 상태를 대체한다. 즉, 리소스 자체가 되어야 한다</li>
</ul>
</li>
<li>따라서<ul>
<li>GET은 form에 있는 정보를 줄테니 나에게 리소스(representation)를 줘</li>
<li>POST는 form에 있는 정보를 줄테니 이걸로 처리 좀 해줘</li>
</ul>
</li>
<li>라는 의미가 되지만,<ul>
<li>DELETE에서 URI는 리소스를 정확하게 식별하고 요청을 보내기 때문에 form을 통해 값을 전달할 게 없으며<ul>
<li>권한을 획득하기 위해선 header를 이용해야할 것 같다</li>
</ul>
</li>
<li>PUT도 전송해야할 것은 대상 리소스를 대체할 representation 그 자체인데, 대상 리소스더러 조각난 form 데이터를 처리하라고 보낼 수는 없는 노릇</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/22/rest-the-beginning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/22/rest-the-beginning/" class="post-title-link" itemprop="url">REST - 긴 여정의 시작</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-22 01:30:00" itemprop="dateCreated datePublished" datetime="2017-05-22T01:30:00+09:00">2017-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/22/rest-the-beginning/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/22/rest-the-beginning/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>연재 목록</p>
<ol>
<li><a href="/2017/05/22/rest-the-beginning/">REST - 긴 여정의 시작</a></li>
<li><a href="/2017/05/23/rest-http-method-in-html-form/">REST - HTML Form에서 GET&#x2F;POST만 지원하는 이유</a></li>
<li><a href="/2017/05/24/rest-the-dissertation-summary/">REST - 논문(요약) 훑어보기</a></li>
<li><a href="/2017/06/12/rest-the-big-lie/">REST - REST 좋아하시네</a></li>
<li><a href="/2017/06/26/rest-the-truth/">REST - Roy가 입을 열다</a></li>
<li><a href="/2017/06/28/rest-the-coclusion/">REST - 당신이 만든 건 REST가 아니지만 괜찮아</a></li>
<li><a href="/2017/06/28/rest-the-dissertation/">REST - 논문 읽기(To Do)</a></li>
</ol>
<h2 id="Representational-State-Transfer"><a href="#Representational-State-Transfer" class="headerlink" title="Representational State Transfer"></a>Representational State Transfer</h2><p><a target="_blank" rel="noopener" href="https://blog.npcode.com/2017/03/02/%EB%B0%94%EC%81%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-rest-%EB%85%BC%EB%AC%B8-%EC%9A%94%EC%95%BD/">바쁜 개발자들을 위한 REST 논문 요약</a></p>
<blockquote>
<p>REST는 Representational State Transfer의 줄임말로, 웹을 위한 네트워크 기반 아키텍처 스타일이다. REST는 Roy T. Fielding이 그의 박사학위 논문 “Architectural Styles and the Design of Network-based Software Architectures” 에서 처음 소개하였다.</p>
</blockquote>
<p>아하.</p>
<p>가장 중요한, Roy의 실제 논문을 아직 읽지 못했다. 논문의 대략적인 내용은 위에 링크를 걸어둔 이응준님의 블로그로부터 이해를 했다.</p>
<p>REST와 HTTP를 이해하기 위해 필수적인 representation의 개념도 그 분의 블로그에서 얻을 수 있으니 미리 보고 올 것을 권한다. </p>
<ul>
<li>representation이란 용어를 단순히 ‘표현’이라고만 번역하기에는 뭔가 놓치는 의미가 있는 것 같아서, 일단은 계속 representation이라고 부르겠다</li>
</ul>
<p>몇 가지 이해 안 되던 부분은 실제 논문으로부터 갈증을 해소하기도 했지만,</p>
<p>논문 전체를 자세히 해석해 나가기에는 지금 좀 지쳤으니 (언젠가) 후속으로 정리를 해야겠다.</p>
<p>지금 시점에는 내가 RESTful하게 설계할 일이 없을 것 같긴 하지만,</p>
<p>웹을 이해하기에는 꽤 좋은 관점이 들어있(다고 추측이 된)다.</p>
<h2 id="REST-아키텍처-스타일"><a href="#REST-아키텍처-스타일" class="headerlink" title="REST 아키텍처 스타일"></a>REST 아키텍처 스타일</h2><p><code>바쁜 개발자들을 위한 REST 논문 요약</code>을 읽기에도 바쁜 개발자들을 위해 요약하자면,</p>
<p>논문에서 Roy는 소프트웨어 아키텍처, 네트워크 기반 어플리케이션 아키텍처, 네트워크 기반 아키텍처 스타일 등을 설명하고,</p>
<p>네트워크 기반 아키텍처의 요구사항, 해결해야할 문제 등을 제시하는데 이에 대한 해결책으로 REST 아키텍처 스타일을 제안한다. </p>
<p>REST는 소프트웨어 아키텍처가 아닌 <a target="_blank" rel="noopener" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm">아키텍처 스타일(architectural style)</a>이라고 정의한다.</p>
<p>후속으로 올릴 REST에 대한 논쟁에서도 REST는 아키텍처 스타일이라고 여러번 강조한다.</p>
<p>많은 IT 용어가 건축에서 왔는데(건축 뿐이겠는가..), 영어권에서는 동일한 단어를 사용하는 서로 다른 용어(동음이의)가 우리말로 번역되면서 각각 다른 단어로 표현되곤 한다.</p>
<p>따라서 어떤 IT 용어가 가진, 원래의 단어에서 오는 뉘앙스나 메타포를 놓치는 경우가 많아 비영어권 국민으로서 참 아쉽다.</p>
<p>많은 REST 논쟁에서 REST를 이해 못하는 사람들이 좀 더 구체적으로 예시를 들어줄 것을 요구하면, 사람들은 REST가 아키텍처 스타일이라고 강조하는 경우가 많았던 것 같다.</p>
<p>아키텍처 스타일(architectural style)은 건축양식을 의미한다. </p>
<p>중세에 고딕양식이 유행을 했다는 말은 고딕양식에 기반해 건물을 설계하고 이 설계를 구현한 건물이 많았다는 말이고(내가 건축 양식의 문외한임은 미리 고백한다),</p>
<p>고딕 성당을 지으려는 설계자는 이 양식을 지키는 선에서 ‘알아서’ 설계를 해야한다.</p>
<p>시장은 설계나 세부 구현에 대한 이해없이 고딕 양식이라는 틀 안에서 요구사항을 제시할 것이고 그러다보면 설계에서도, 구현에서도 best practice가 퍼지게 되겠지.</p>
<p>수십개의 성당을 지어야 하는 작업 반장의 커뮤니티에서는 이 세부 구현이 곧 고딕 양식이다라고 인식될 수 있다. 그가 얼마나 뛰어난 작업 반장인지와는 상관없이.</p>
<p>물론 이런 식의 건축 양식이 시간을 두고 확립되었다면, REST는 태초에 명확한 제약사항이 존재했다는 차이가 있긴 하다.</p>
<p>기와집이라는 건축양식이 있다고 할 때, 청기와 주유소는 과연 기와집인가? (기와는 맞는데 집이 아닌가? 흠..)</p>
<p>아니라면 기와집이라는 건축양식을 현대에는 의미를 확장해야할 필요가 있지 않은가? </p>
<p>어쩌면 사회적 합의를 봐야할 지도 모르겠다.</p>
<p>REST처럼 작성자가 확실하며, 애초에 확실한 제약 사항이 있는 분야도 합의의 대상인가?</p>
<hr>
<p>REST에 관해서는 온갖 블로그와 구현체에서 서로 다르게 해석하고 있다.</p>
<p>작성자의 역량 + 독자의 역량이 오해를 재생산하기도 한다.</p>
<p>그러니 지금 이 정리를 본 누군가도 역시 오해를 얻어가리라 믿는다. 나 때문이든 당신 때문이든.</p>
<p>우선 REST에 대해 알아보자.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/18/learning-api-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/18/learning-api-design/" class="post-title-link" itemprop="url">API Design을 들여다보다</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-18 23:28:44" itemprop="dateCreated datePublished" datetime="2017-05-18T23:28:44+09:00">2017-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/18/learning-api-design/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/18/learning-api-design/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h2><p>생각해보니 내가 API를 제대로 만들어 본 적이 없었더랬다.</p>
<p>GraphQL이 재미있어 보이니 써보고는 싶은데, </p>
<p>사실 난 인증을 붙인 프로덕션 레벨의 코드를 만들어 본 적이 없다.</p>
<p>왜 좋은가를 설명하려면 널리 퍼진 아키텍처 스타일을 기반으로 설명하면 좋을텐데,</p>
<p>나는 REST는 설명할 수 있던가? HTTP는?</p>
<p>나는 정확히 설명할 수 없다.</p>
<p>그럼 해야지.</p>
<p>지금까지는 지식 습득의 드라이브를 발표를 통해 얻었다면, 이제 블로그에 정리하면서 익혀보려고 한다.</p>
<h2 id="What-to-do"><a href="#What-to-do" class="headerlink" title="What to do"></a>What to do</h2><p>‘정확히 알기’ 그 첫번째 과정으로 API 디자인에 도전해본다.</p>
<p>이 시리즈가 끝날 즈음이면 나는</p>
<ul>
<li>API 서버를 구축해서 인증을 붙여본다</li>
<li>전통적인 RESTful API와 GraphQL 서버 모두 구현</li>
<li>REST에 대해 제대로 설명하게 된다</li>
<li>여러 인증 과정을 경험해본다</li>
<li>HTTP에 대해 설명을 할 수 있게 된다</li>
</ul>
<p>동시에</p>
<ul>
<li>HTTP 완벽가이드 릴레이 세미나<ul>
<li>HTTP 완벽가이드로 적당히 완벽히 알기(금새 또 적당히 적당히 하려는 버릇이..)</li>
<li>여기에 몇가지 간단한 책(그림으로 배우는 시리즈)도 참고로 읽기</li>
</ul>
</li>
</ul>
<h2 id="And-how"><a href="#And-how" class="headerlink" title="And how?"></a>And how?</h2><p>검색과 블로그와 책으로부터 얻은 지식을 에버노트에 거칠게 정리한 다음 블로그에 옮겨 담기로..</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://haah.kr/2017/05/18/declare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngiggy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha-ah">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ha-ah">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/18/declare/" class="post-title-link" itemprop="url">블로그를 시작하겠노라고 선언하다</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2017-05-18 22:02:20" itemprop="dateCreated datePublished" datetime="2017-05-18T22:02:20+09:00">2017-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2018-02-13 15:27:02" itemprop="dateModified" datetime="2018-02-13T15:27:02+09:00">2018-02-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/05/18/declare/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/18/declare/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="내가-은연-중-피하려고-했던-것들"><a href="#내가-은연-중-피하려고-했던-것들" class="headerlink" title="내가 은연 중 피하려고 했던 것들"></a>내가 은연 중 피하려고 했던 것들</h2><p>기술 블로그와 신세 한탄이 섞여있겠지만,</p>
<p>익숙하지 않은 것을 시도해보기로 했다.</p>
<h2 id="그리고-2017-05-18-오늘"><a href="#그리고-2017-05-18-오늘" class="headerlink" title="그리고 2017.05.18 오늘"></a>그리고 2017.05.18 오늘</h2><p>오랜만에 제창된 임을 위한 행진곡</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/UdKgerP9O7Q" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>RIP. Chris Cornell</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/IuUDRU9-HRk" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youngiggy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"youngiggy-github-io","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
